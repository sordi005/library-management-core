<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="originalContent" value="#  Library Management System&#10;&#10;&gt; **Sistema de gestión bibliotecaria con arquitectura hexagonal y API REST nativa**&#10;&#10;[![Java](https://img.shields.io/badge/Java-21-orange.svg)](https://www.oracle.com/java/)&#10;[![Gradle](https://img.shields.io/badge/Gradle-8.5-blue.svg)](https://gradle.org/)&#10;[![Hibernate](https://img.shields.io/badge/Hibernate-6.4.4-green.svg)](https://hibernate.org/)&#10;[![MySQL](https://img.shields.io/badge/MySQL-8.0-blue.svg)](https://www.mysql.com/)&#10;&#10;##  **Descripción**&#10;&#10;Sistema de gestión bibliotecaria desarrollado con **arquitectura hexagonal**, implementando patrones enterprise y buenas prácticas de desarrollo. Construido **sin frameworks** para demostrar conocimientos fundamentales de Java y arquitectura de software.&#10;&#10;## ️ **Arquitectura**&#10;&#10;```&#10; Clean Architecture / Hexagonal&#10;├──  Presentation Layer (Controllers)&#10;├──  Application Layer (Services)  &#10;├──  Domain Layer (Entities/Models)&#10;├──  Infrastructure Layer (Repositories)&#10;├──  Mapping Layer (DTOs/Mappers)&#10;└── ⚡ Cross-cutting (Exceptions/Utils)&#10;```&#10;&#10;### **Principios Aplicados**&#10;- ✅ **SOLID Principles**&#10;- ✅ **Clean Architecture**&#10;- ✅ **Domain-Driven Design (DDD)**&#10;- ✅ **Repository Pattern**&#10;- ✅ **Dependency Injection**&#10;- ✅ **Exception Handling Strategy**&#10;&#10;##  **Tecnologías**&#10;&#10;| Categoría | Tecnología | Propósito |&#10;|-----------|------------|-----------|&#10;| **Core** | Java 21 | Lenguaje base |&#10;| **Build** | Gradle 8.5 | Gestión de dependencias |&#10;| **ORM** | Hibernate 6.4.4 | Mapeo objeto-relacional |&#10;| **Database** | MySQL 8.0 | Base de datos |&#10;| **Validation** | Jakarta Validation | Validación de DTOs |&#10;| **HTTP** | Java Native HTTP Server | API REST |&#10;| **Logging** | Custom Logger | Sistema de logs |&#10;| **Testing** | JUnit 5 | Testing unitario |&#10;&#10;##  **Estado del Proyecto**&#10;&#10;### ✅ **Completado**&#10;- **Modelos de dominio**: Todas las entidades (User, Book, Loan, etc.)&#10;- **DTOs**: Todos los DTOs para transferencia de datos&#10;- **API Users**: CRUD completo de usuarios&#10;- **Arquitectura base**: Configuración y estructura&#10;- **Manejo de excepciones**: Sistema centralizado&#10;- **Logging**: Sistema profesional implementado&#10;&#10;###  **En Desarrollo**&#10;- APIs para Books, Loans, Authors, etc.&#10;- Sistema de autenticación&#10;- Validaciones avanzadas&#10;- Documentación OpenAPI&#10;&#10;## ️ **Instalación y Configuración**&#10;&#10;### **Prerrequisitos**&#10;```bash&#10;Java 21+&#10;MySQL 8.0+&#10;Gradle 8.5+&#10;```&#10;&#10;### **1. Clonar Repositorio**&#10;```bash&#10;git clone &lt;repository-url&gt;&#10;cd library-management-core&#10;```&#10;&#10;### **2. Configurar Base de Datos**&#10;```sql&#10;CREATE DATABASE librarydb;&#10;```&#10;&#10;### **3. Configurar Conexión**&#10;Editar `src/main/resources/META-INF/persistence.xml`:&#10;```xml&#10;&lt;property name=&quot;javax.persistence.jdbc.url&quot; value=&quot;jdbc:mysql://localhost:3306/librarydb&quot;/&gt;&#10;&lt;property name=&quot;javax.persistence.jdbc.user&quot; value=&quot;tu_usuario&quot;/&gt;&#10;&lt;property name=&quot;javax.persistence.jdbc.password&quot; value=&quot;tu_password&quot;/&gt;&#10;```&#10;&#10;### **4. Ejecutar Aplicación**&#10;```bash&#10;./gradlew run&#10;```&#10;&#10;**Servidor iniciará en:** `http://localhost:8080`&#10;&#10;##  **API Endpoints**&#10;&#10;### ** Users API**&#10;&#10;| Método | Endpoint | Descripción | Body |&#10;|--------|----------|-------------|------|&#10;| `GET` | `/api/users` | Listar todos los usuarios | - |&#10;| `GET` | `/api/users/{id}` | Obtener usuario por ID | - |&#10;| `POST` | `/api/users` | Crear nuevo usuario | CreateUserDTO |&#10;| `PUT` | `/api/users/{id}` | Actualizar usuario | UpdateUserDTO |&#10;| `DELETE` | `/api/users/{id}` | Eliminar usuario | - |&#10;&#10;### ** Health Check**&#10;| Método | Endpoint | Descripción |&#10;|--------|----------|-------------|&#10;| `GET` | `/health` | Estado del servicio |&#10;&#10;##  **Ejemplos de Uso**&#10;&#10;### **Crear Usuario**&#10;```bash&#10;POST /api/users&#10;Content-Type: application/json&#10;&#10;{&#10;  &quot;firstName&quot;: &quot;Juan&quot;,&#10;  &quot;lastName&quot;: &quot;Pérez&quot;,&#10;  &quot;email&quot;: &quot;juan.perez@email.com&quot;,&#10;  &quot;phoneNumber&quot;: &quot;+54911234567&quot;,&#10;  &quot;dateOfBirth&quot;: &quot;1990-05-15&quot;,&#10;  &quot;dni&quot;: &quot;12345678&quot;,&#10;  &quot;address&quot;: {&#10;    &quot;street&quot;: &quot;Av. Corrientes&quot;,&#10;    &quot;number&quot;: &quot;1234&quot;,&#10;    &quot;city&quot;: &quot;Buenos Aires&quot;,&#10;    &quot;province&quot;: &quot;CABA&quot;,&#10;    &quot;country&quot;: &quot;Argentina&quot;,&#10;    &quot;postalCode&quot;: &quot;C1043&quot;&#10;  }&#10;}&#10;```&#10;&#10;### **Actualizar Usuario**&#10;```bash&#10;PUT /api/users/1&#10;Content-Type: application/json&#10;&#10;{&#10;  &quot;firstName&quot;: &quot;Juan Carlos&quot;,&#10;  &quot;lastName&quot;: &quot;Pérez&quot;,&#10;  &quot;email&quot;: &quot;juan.carlos@email.com&quot;,&#10;  &quot;phoneNumber&quot;: &quot;+54911234567&quot;,&#10;  &quot;dateOfBirth&quot;: &quot;1990-05-15&quot;&#10;}&#10;```&#10;&#10;## ️ **Estructura del Proyecto**&#10;&#10;```&#10;src/main/java/com/libraryManagement/&#10;├──  config/                 # Configuraciones&#10;│   ├── db/                    # Configuración JPA&#10;│   ├── server/                # Servidor HTTP&#10;│   ├── dependency/            # Inyección de dependencias&#10;│   └── data/                  # Datos de prueba&#10;├──  model/                  # Entidades de dominio&#10;├──  dto/                    # Data Transfer Objects&#10;├──  mapper/                 # Transformadores DTO ↔ Entity&#10;├──  repository/             # Acceso a datos&#10;├──  service/                # Lógica de negocio&#10;├──  controller/             # Controladores REST&#10;├──  exception/              # Manejo de excepciones&#10;├──  validation/             # Validadores&#10;└──  util/                   # Utilidades&#10;```&#10;&#10;##  **Características Técnicas**&#10;&#10;### ** Dependency Injection Manual**&#10;```java&#10;@Component&#10;public class DependencyContainer {&#10;    // Gestión manual de dependencias sin Spring&#10;}&#10;```&#10;&#10;### **️ Exception Handling Centralizado**&#10;```java&#10;@GlobalExceptionHandler&#10;public class GlobalExceptionHandler {&#10;    // Manejo centralizado de todas las excepciones&#10;}&#10;```&#10;&#10;### ** Logging Profesional**&#10;```java&#10;Logger.info(&quot;UserService&quot;, &quot;Usuario creado exitosamente&quot;);&#10;Logger.error(&quot;UserService&quot;, &quot;Error al crear usuario&quot;, exception);&#10;```&#10;&#10;### ** Context-Based Mapping**&#10;```java&#10;// Mapeo inteligente según contexto&#10;UserDetailDTO detailDTO = userMapper.toDetailDTO(user, &#10;    UserMappingContext.withLoans());&#10;```&#10;&#10;##  **Testing**&#10;&#10;```bash&#10;# Ejecutar tests&#10;./gradlew test&#10;&#10;# Ver reporte de cobertura&#10;./gradlew jacocoTestReport&#10;```&#10;&#10;##  **Roadmap**&#10;&#10;### ** Próximas Funcionalidades**&#10;- [ ] **Books API** - Gestión de libros&#10;- [ ] **Loans API** - Sistema de préstamos&#10;- [ ] **Authors API** - Gestión de autores&#10;- [ ] **Authentication** - JWT Security&#10;- [ ] **Swagger Documentation** - API docs&#10;- [ ] **Docker** - Containerización&#10;- [ ] **Spring Migration** - Migración a Spring Boot&#10;&#10;## ‍ **Autor**&#10;&#10;**Santiago Sordi Gil**&#10;- Email: sordisantiago@gmail.com&#10;- LinkedIn: [Tu perfil]&#10;- GitHub: [Tu perfil]&#10;&#10;##  **Licencia**&#10;&#10;Este proyecto está bajo la licencia MIT - ver [LICENSE.md](LICENSE.md) para detalles.&#10;&#10;---&#10;&#10;&gt; **&quot;Código limpio no es escrito siguiendo reglas. Es escrito por programadores que se preocupan por hacer que el código sea legible y mantenible.&quot;** - Robert C. Martin&#10;" />
              <option name="updatedContent" value="#  Library Management System&#10;&#10;&gt; **Sistema de gestión bibliotecaria con arquitectura hexagonal y API REST nativa**&#10;&#10;[![Java](https://img.shields.io/badge/Java-21-orange.svg)](https://www.oracle.com/java/)&#10;[![Gradle](https://img.shields.io/badge/Gradle-8.5-blue.svg)](https://gradle.org/)&#10;[![Hibernate](https://img.shields.io/badge/Hibernate-6.4.4-green.svg)](https://hibernate.org/)&#10;[![MySQL](https://img.shields.io/badge/MySQL-8.0-blue.svg)](https://www.mysql.com/)&#10;&#10;##  **Descripción**&#10;&#10;Sistema de gestión bibliotecaria desarrollado con **arquitectura hexagonal**, implementando patrones enterprise y buenas prácticas de desarrollo. Construido **sin frameworks** para demostrar conocimientos fundamentales de Java y arquitectura de software.&#10;&#10;## ️ **Arquitectura**&#10;&#10;```&#10; Clean Architecture / Hexagonal&#10;├──  Presentation Layer (Controllers)&#10;├──  Application Layer (Services)  &#10;├──  Domain Layer (Entities/Models)&#10;├──  Infrastructure Layer (Repositories)&#10;├──  Mapping Layer (DTOs/Mappers)&#10;└── ⚡ Cross-cutting (Exceptions/Utils)&#10;```&#10;&#10;### **Principios Aplicados**&#10;- ✅ **SOLID Principles**&#10;- ✅ **Clean Architecture**&#10;- ✅ **Domain-Driven Design (DDD)**&#10;- ✅ **Repository Pattern**&#10;- ✅ **Dependency Injection**&#10;- ✅ **Exception Handling Strategy**&#10;&#10;##  **Tecnologías**&#10;&#10;| Categoría | Tecnología | Propósito |&#10;|-----------|------------|-----------|&#10;| **Core** | Java 21 | Lenguaje base |&#10;| **Build** | Gradle 8.5 | Gestión de dependencias |&#10;| **ORM** | Hibernate 6.4.4 | Mapeo objeto-relacional |&#10;| **Database** | MySQL 8.0 | Base de datos |&#10;| **Validation** | Jakarta Validation | Validación de DTOs |&#10;| **HTTP** | Java Native HTTP Server | API REST |&#10;| **Logging** | Custom Logger | Sistema de logs |&#10;| **Testing** | JUnit 5 | Testing unitario |&#10;&#10;##  **Estado del Proyecto**&#10;&#10;### ✅ **Completado**&#10;- **Modelos de dominio**: Todas las entidades (User, Book, Loan, etc.)&#10;- **DTOs**: Todos los DTOs para transferencia de datos&#10;- **API Users**: CRUD completo de usuarios&#10;- **Arquitectura base**: Configuración y estructura&#10;- **Manejo de excepciones**: Sistema centralizado&#10;- **Logging**: Sistema profesional implementado&#10;&#10;###  **En Desarrollo**&#10;- APIs para Books, Loans, Authors, etc.&#10;- Sistema de autenticación&#10;- Validaciones avanzadas&#10;- Documentación OpenAPI&#10;&#10;## ️ **Instalación y Configuración**&#10;&#10;### **Prerrequisitos**&#10;```bash&#10;Java 21+&#10;MySQL 8.0+ (solo el servidor, la BD se crea automáticamente)&#10;Gradle 8.5+&#10;```&#10;&#10;### **1. Clonar Repositorio**&#10;```bash&#10;git clone &lt;repository-url&gt;&#10;cd library-management-core&#10;```&#10;&#10;### **2. Configurar MySQL**&#10;Solo necesitas tener **MySQL Server** ejecutándose en `localhost:3306` con:&#10;- Usuario: `root`&#10;- Password: `1234`&#10;&#10;**¡La base de datos `librarydb` se crea automáticamente!** ✨&#10;&#10;### **3. Ejecutar Aplicación**&#10;```bash&#10;./gradlew run&#10;```&#10;&#10;**El sistema automáticamente:**&#10;- ✅ Verifica conexión a MySQL&#10;- ✅ Crea la base de datos `librarydb` si no existe&#10;- ✅ Crea todas las tablas automáticamente&#10;- ✅ Carga datos de prueba&#10;- ✅ Inicia el servidor en `http://localhost:8080`&#10;&#10;##  **API Endpoints**&#10;&#10;### ** Users API**&#10;&#10;| Método | Endpoint | Descripción | Body |&#10;|--------|----------|-------------|------|&#10;| `GET` | `/api/users` | Listar todos los usuarios | - |&#10;| `GET` | `/api/users/{id}` | Obtener usuario por ID | - |&#10;| `POST` | `/api/users` | Crear nuevo usuario | CreateUserDTO |&#10;| `PUT` | `/api/users/{id}` | Actualizar usuario | UpdateUserDTO |&#10;| `DELETE` | `/api/users/{id}` | Eliminar usuario | - |&#10;&#10;### ** Health Check**&#10;| Método | Endpoint | Descripción |&#10;|--------|----------|-------------|&#10;| `GET` | `/health` | Estado del servicio |&#10;&#10;##  **Ejemplos de Uso**&#10;&#10;### **Crear Usuario**&#10;```bash&#10;POST /api/users&#10;Content-Type: application/json&#10;&#10;{&#10;  &quot;firstName&quot;: &quot;Juan&quot;,&#10;  &quot;lastName&quot;: &quot;Pérez&quot;,&#10;  &quot;email&quot;: &quot;juan.perez@email.com&quot;,&#10;  &quot;phoneNumber&quot;: &quot;+54911234567&quot;,&#10;  &quot;dateOfBirth&quot;: &quot;1990-05-15&quot;,&#10;  &quot;dni&quot;: &quot;12345678&quot;,&#10;  &quot;address&quot;: {&#10;    &quot;street&quot;: &quot;Av. Corrientes&quot;,&#10;    &quot;number&quot;: &quot;1234&quot;,&#10;    &quot;city&quot;: &quot;Buenos Aires&quot;,&#10;    &quot;province&quot;: &quot;CABA&quot;,&#10;    &quot;country&quot;: &quot;Argentina&quot;,&#10;    &quot;postalCode&quot;: &quot;C1043&quot;&#10;  }&#10;}&#10;```&#10;&#10;### **Actualizar Usuario**&#10;```bash&#10;PUT /api/users/1&#10;Content-Type: application/json&#10;&#10;{&#10;  &quot;firstName&quot;: &quot;Juan Carlos&quot;,&#10;  &quot;lastName&quot;: &quot;Pérez&quot;,&#10;  &quot;email&quot;: &quot;juan.carlos@email.com&quot;,&#10;  &quot;phoneNumber&quot;: &quot;+54911234567&quot;,&#10;  &quot;dateOfBirth&quot;: &quot;1990-05-15&quot;&#10;}&#10;```&#10;&#10;## ️ **Estructura del Proyecto**&#10;&#10;```&#10;src/main/java/com/libraryManagement/&#10;├──  config/                 # Configuraciones&#10;│   ├── db/                    # Configuración JPA&#10;│   ├── server/                # Servidor HTTP&#10;│   ├── dependency/            # Inyección de dependencias&#10;│   └── data/                  # Datos de prueba&#10;├──  model/                  # Entidades de dominio&#10;├──  dto/                    # Data Transfer Objects&#10;├──  mapper/                 # Transformadores DTO ↔ Entity&#10;├──  repository/             # Acceso a datos&#10;├──  service/                # Lógica de negocio&#10;├──  controller/             # Controladores REST&#10;├──  exception/              # Manejo de excepciones&#10;├──  validation/             # Validadores&#10;└──  util/                   # Utilidades&#10;```&#10;&#10;##  **Características Técnicas**&#10;&#10;### ** Dependency Injection Manual**&#10;```java&#10;@Component&#10;public class DependencyContainer {&#10;    // Gestión manual de dependencias sin Spring&#10;}&#10;```&#10;&#10;### **️ Exception Handling Centralizado**&#10;```java&#10;@GlobalExceptionHandler&#10;public class GlobalExceptionHandler {&#10;    // Manejo centralizado de todas las excepciones&#10;}&#10;```&#10;&#10;### ** Logging Profesional**&#10;```java&#10;Logger.info(&quot;UserService&quot;, &quot;Usuario creado exitosamente&quot;);&#10;Logger.error(&quot;UserService&quot;, &quot;Error al crear usuario&quot;, exception);&#10;```&#10;&#10;### ** Context-Based Mapping**&#10;```java&#10;// Mapeo inteligente según contexto&#10;UserDetailDTO detailDTO = userMapper.toDetailDTO(user, &#10;    UserMappingContext.withLoans());&#10;```&#10;&#10;##  **Testing**&#10;&#10;```bash&#10;# Ejecutar tests&#10;./gradlew test&#10;&#10;# Ver reporte de cobertura&#10;./gradlew jacocoTestReport&#10;```&#10;&#10;##  **Roadmap**&#10;&#10;### ** Próximas Funcionalidades**&#10;- [ ] **Books API** - Gestión de libros&#10;- [ ] **Loans API** - Sistema de préstamos&#10;- [ ] **Authors API** - Gestión de autores&#10;- [ ] **Authentication** - JWT Security&#10;- [ ] **Swagger Documentation** - API docs&#10;- [ ] **Docker** - Containerización&#10;- [ ] **Spring Migration** - Migración a Spring Boot&#10;&#10;## ‍ **Autor**&#10;&#10;**Santiago Sordi Gil**&#10;- Email: sordisantiago@gmail.com&#10;- LinkedIn: [Tu perfil]&#10;- GitHub: [Tu perfil]&#10;&#10;##  **Licencia**&#10;&#10;Este proyecto está bajo la licencia MIT - ver [LICENSE.md](LICENSE.md) para detalles.&#10;&#10;---&#10;&#10;&gt; **&quot;Código limpio no es escrito siguiendo reglas. Es escrito por programadores que se preocupan por hacer que el código sea legible y mantenible.&quot;** - Robert C. Martin" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/Main.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/Main.java" />
              <option name="updatedContent" value="package com.libraryManagement;&#10;&#10;import com.libraryManagement.config.ApplicationBootstrap;&#10;&#10;/**&#10; *  PUNTO DE ENTRADA PRINCIPAL DE LA APLICACIÓN&#10; * &#10; * Clase Main que inicia todo el sistema Library Management&#10; */&#10;public class Main {&#10;&#10;    public static void main(String[] args) {&#10;        System.out.println(&quot;=&quot;.repeat(60));&#10;        System.out.println(&quot; LIBRARY MANAGEMENT SYSTEM&quot;);&#10;        System.out.println(&quot;=&quot;.repeat(60));&#10;&#10;        // Crear e iniciar el bootstrap de la aplicación&#10;        ApplicationBootstrap bootstrap = new ApplicationBootstrap();&#10;        &#10;        try {&#10;            // Iniciar todo el sistema&#10;            bootstrap.start();&#10;            &#10;            // Mantener la aplicación corriendo&#10;            System.out.println(&quot;\n Presiona Ctrl+C para detener el servidor&quot;);&#10;            &#10;            // Mantener el hilo principal vivo&#10;            Thread.currentThread().join();&#10;            &#10;        } catch (Exception e) {&#10;            System.err.println(&quot; Error fatal en la aplicación: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;            System.exit(1);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/ApplicationBootstrap.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/ApplicationBootstrap.java" />
              <option name="originalContent" value="package com.libraryManagement.config;&#10;&#10;import com.libraryManagement.config.data.SampleDataLoader;&#10;import com.libraryManagement.config.db.JpaConfig;&#10;import com.libraryManagement.config.dependency.DependencyContainer;&#10;import com.libraryManagement.config.server.RouteRegistry;&#10;import com.libraryManagement.config.server.ServerConfiguration;&#10;import com.libraryManagement.controller.UserController;&#10;import com.libraryManagement.util.Logger; // ← AGREGADO: Logger profesional&#10;import com.sun.net.httpserver.HttpServer;&#10;&#10;/**&#10; * Bootstrap principal de la aplicación&#10; * Responsabilidad: Orquestar la inicialización completa del sistema&#10; */&#10;public class ApplicationBootstrap {&#10;&#10;    private HttpServer server;&#10;    private DependencyContainer container;&#10;    private ServerConfiguration serverConfig;&#10;    private RouteRegistry routeRegistry;&#10;&#10;    /**&#10;     * Método principal de arranque&#10;     */&#10;    public void start() {&#10;        try {&#10;            Logger.info(&quot;ApplicationBootstrap&quot;, &quot;Iniciando Library Management System...&quot;);&#10;&#10;            // 1. Verificar conexión a base de datos&#10;            initializeDatabase();&#10;&#10;            // 2. Cargar datos de muestra si es necesario - Desarrollo&#10;            loadSampleData();&#10;&#10;            // 3. Inicializar contenedor de dependencias&#10;            initializeDependencies();&#10;&#10;            // 4. Configurar servidor HTTP&#10;            configureServer();&#10;&#10;            // 5. Iniciar servidor&#10;            startServer();&#10;&#10;            Logger.success(&quot;ApplicationBootstrap&quot;, &quot;Sistema iniciado correctamente!&quot;);&#10;            Logger.info(&quot;ApplicationBootstrap&quot;, &quot;Servidor ejecutándose en: http://localhost:8080&quot;);&#10;&#10;        } catch (Exception e) {&#10;            Logger.error(&quot;ApplicationBootstrap&quot;, &quot;Error fatal durante el arranque&quot;, e);&#10;            shutdown();&#10;            throw new RuntimeException(&quot; Error fatal durante el arranque&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Inicializa la base de datos&#10;     */&#10;    private void initializeDatabase() {&#10;        try {&#10;            Logger.info(&quot;ApplicationBootstrap&quot;, &quot;Inicializando conexión a base de datos...&quot;);&#10;&#10;            // Verificar que JPA se inicialice correctamente&#10;            JpaConfig.getEntityManagerFactory();&#10;&#10;            Logger.success(&quot;ApplicationBootstrap&quot;, &quot;Base de datos conectada&quot;);&#10;&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot; Error al conectar con la base de datos&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Carga datos de muestra si es necesario&#10;     */&#10;    private void loadSampleData() {&#10;        try {&#10;            SampleDataLoader.loadSampleData();&#10;        } catch (Exception e) {&#10;            Logger.error(&quot;ApplicationBootstrap&quot;, &quot;Error cargando datos de prueba&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Inicializa el contenedor de dependencias&#10;     */&#10;    private void initializeDependencies() {&#10;        Logger.info(&quot;ApplicationBootstrap&quot;, &quot;Inicializando dependencias...&quot;);&#10;        container = new DependencyContainer();&#10;        container.initializeDependencies();&#10;    }&#10;&#10;    /**&#10;     * Configura el servidor HTTP&#10;     */&#10;    private void configureServer() {&#10;        try {&#10;            Logger.info(&quot;ApplicationBootstrap&quot;, &quot;Configurando servidor HTTP...&quot;);&#10;&#10;            serverConfig = new ServerConfiguration();&#10;            server = serverConfig.createServer();&#10;&#10;            routeRegistry = new RouteRegistry(server);&#10;            registerRoutes();&#10;&#10;            Logger.success(&quot;ApplicationBootstrap&quot;, &quot;Servidor HTTP configurado&quot;);&#10;&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot; Error configurando servidor HTTP&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Registra todas las rutas&#10;     */&#10;    private void registerRoutes() {&#10;        Logger.debug(&quot;ApplicationBootstrap&quot;, &quot;Registrando rutas...&quot;);&#10;&#10;        // Obtener controllers del contenedor&#10;        UserController userController = container.getController(UserController.class);&#10;&#10;        // Registrar rutas&#10;        routeRegistry.registerUserRoutes(userController);&#10;        routeRegistry.registerHealthCheck();&#10;&#10;        Logger.info(&quot;ApplicationBootstrap&quot;, &quot;Rutas registradas:&quot;);&#10;        Logger.info(&quot;ApplicationBootstrap&quot;, &quot;   GET/POST/PUT/DELETE /api/users - Gestión de usuarios&quot;);&#10;        Logger.info(&quot;ApplicationBootstrap&quot;, &quot;   GET /health - Health check&quot;);&#10;    }&#10;&#10;    /**&#10;     * Inicia el servidor&#10;     */&#10;    private void startServer() {&#10;        Logger.info(&quot;ApplicationBootstrap&quot;, &quot;Iniciando servidor...&quot;);&#10;        server.start();&#10;    }&#10;&#10;    /**&#10;     * Detiene el sistema&#10;     */&#10;    public void shutdown() {&#10;        Logger.info(&quot;ApplicationBootstrap&quot;, &quot;Deteniendo sistema...&quot;);&#10;&#10;        if (server != null) {&#10;            server.stop(0);&#10;        }&#10;&#10;        if (container != null) {&#10;            container.shutdown();&#10;        }&#10;&#10;        Logger.info(&quot;ApplicationBootstrap&quot;, &quot;Sistema detenido&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.libraryManagement.config;&#10;&#10;import com.libraryManagement.config.data.SampleDataLoader;&#10;import com.libraryManagement.config.db.DatabaseInitializer;&#10;import com.libraryManagement.config.db.JpaConfig;&#10;import com.libraryManagement.config.dependency.DependencyContainer;&#10;import com.libraryManagement.config.server.RouteRegistry;&#10;import com.libraryManagement.config.server.ServerConfiguration;&#10;import com.libraryManagement.controller.UserController;&#10;import com.libraryManagement.util.Logger; // ← AGREGADO: Logger profesional&#10;import com.sun.net.httpserver.HttpServer;&#10;&#10;/**&#10; * Bootstrap principal de la aplicación&#10; * Responsabilidad: Orquestar la inicialización completa del sistema&#10; */&#10;public class ApplicationBootstrap {&#10;&#10;    private HttpServer server;&#10;    private DependencyContainer container;&#10;    private ServerConfiguration serverConfig;&#10;    private RouteRegistry routeRegistry;&#10;&#10;    /**&#10;     * Método principal de arranque&#10;     */&#10;    public void start() {&#10;        try {&#10;            Logger.info(&quot;ApplicationBootstrap&quot;, &quot;Iniciando Library Management System...&quot;);&#10;&#10;            // 1. Verificar conexión a base de datos&#10;            initializeDatabase();&#10;&#10;            // 2. Cargar datos de muestra si es necesario - Desarrollo&#10;            loadSampleData();&#10;&#10;            // 3. Inicializar contenedor de dependencias&#10;            initializeDependencies();&#10;&#10;            // 4. Configurar servidor HTTP&#10;            configureServer();&#10;&#10;            // 5. Iniciar servidor&#10;            startServer();&#10;&#10;            Logger.success(&quot;ApplicationBootstrap&quot;, &quot;Sistema iniciado correctamente!&quot;);&#10;            Logger.info(&quot;ApplicationBootstrap&quot;, &quot;Servidor ejecutándose en: http://localhost:8080&quot;);&#10;&#10;        } catch (Exception e) {&#10;            Logger.error(&quot;ApplicationBootstrap&quot;, &quot;Error fatal durante el arranque&quot;, e);&#10;            shutdown();&#10;            throw new RuntimeException(&quot; Error fatal durante el arranque&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Inicializa la base de datos&#10;     */&#10;    private void initializeDatabase() {&#10;        try {&#10;            Logger.info(&quot;ApplicationBootstrap&quot;, &quot; Inicializando conexión a base de datos...&quot;);&#10;&#10;            // ✨ PASO 1: Inicializar BD automáticamente&#10;            DatabaseInitializer.initializeDatabase();&#10;            &#10;            // ✨ PASO 2: Verificar que JPA se inicialice correctamente&#10;            JpaConfig.getEntityManagerFactory();&#10;            &#10;            // ✨ PASO 3: Mostrar información de la BD&#10;            DatabaseInitializer.printDatabaseInfo();&#10;&#10;            Logger.success(&quot;ApplicationBootstrap&quot;, &quot;✅ Base de datos conectada&quot;);&#10;&#10;        } catch (Exception e) {&#10;            Logger.error(&quot;ApplicationBootstrap&quot;, &quot;❌ Error al conectar con la base de datos&quot;, e);&#10;            throw new RuntimeException(&quot;❌ Error fatal durante el arranque&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Carga datos de muestra si es necesario&#10;     */&#10;    private void loadSampleData() {&#10;        try {&#10;            SampleDataLoader.loadSampleData();&#10;        } catch (Exception e) {&#10;            Logger.error(&quot;ApplicationBootstrap&quot;, &quot;Error cargando datos de prueba&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Inicializa el contenedor de dependencias&#10;     */&#10;    private void initializeDependencies() {&#10;        Logger.info(&quot;ApplicationBootstrap&quot;, &quot;Inicializando dependencias...&quot;);&#10;        container = new DependencyContainer();&#10;        container.initializeDependencies();&#10;    }&#10;&#10;    /**&#10;     * Configura el servidor HTTP&#10;     */&#10;    private void configureServer() {&#10;        try {&#10;            Logger.info(&quot;ApplicationBootstrap&quot;, &quot;Configurando servidor HTTP...&quot;);&#10;&#10;            serverConfig = new ServerConfiguration();&#10;            server = serverConfig.createServer();&#10;&#10;            routeRegistry = new RouteRegistry(server);&#10;            registerRoutes();&#10;&#10;            Logger.success(&quot;ApplicationBootstrap&quot;, &quot;Servidor HTTP configurado&quot;);&#10;&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot; Error configurando servidor HTTP&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Registra todas las rutas&#10;     */&#10;    private void registerRoutes() {&#10;        Logger.debug(&quot;ApplicationBootstrap&quot;, &quot;Registrando rutas...&quot;);&#10;&#10;        // Obtener controllers del contenedor&#10;        UserController userController = container.getController(UserController.class);&#10;&#10;        // Registrar rutas&#10;        routeRegistry.registerUserRoutes(userController);&#10;        routeRegistry.registerHealthCheck();&#10;&#10;        Logger.info(&quot;ApplicationBootstrap&quot;, &quot;Rutas registradas:&quot;);&#10;        Logger.info(&quot;ApplicationBootstrap&quot;, &quot;   GET/POST/PUT/DELETE /api/users - Gestión de usuarios&quot;);&#10;        Logger.info(&quot;ApplicationBootstrap&quot;, &quot;   GET /health - Health check&quot;);&#10;    }&#10;&#10;    /**&#10;     * Inicia el servidor&#10;     */&#10;    private void startServer() {&#10;        Logger.info(&quot;ApplicationBootstrap&quot;, &quot;Iniciando servidor...&quot;);&#10;        server.start();&#10;    }&#10;&#10;    /**&#10;     * Detiene el sistema&#10;     */&#10;    public void shutdown() {&#10;        Logger.info(&quot;ApplicationBootstrap&quot;, &quot;Deteniendo sistema...&quot;);&#10;&#10;        if (server != null) {&#10;            server.stop(0);&#10;        }&#10;&#10;        if (container != null) {&#10;            container.shutdown();&#10;        }&#10;&#10;        Logger.info(&quot;ApplicationBootstrap&quot;, &quot;Sistema detenido&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/db/DatabaseInitializer.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/db/DatabaseInitializer.java" />
              <option name="updatedContent" value="package com.libraryManagement.config.db;&#10;&#10;import com.libraryManagement.util.Logger;&#10;import java.sql.Connection;&#10;import java.sql.DriverManager;&#10;import java.sql.Statement;&#10;import java.sql.SQLException;&#10;&#10;/**&#10; * ️ INICIALIZADOR DE BASE DE DATOS&#10; * &#10; * Maneja la creación automática de la base de datos y configuraciones iniciales&#10; * de forma robusta y profesional.&#10; */&#10;public class DatabaseInitializer {&#10;    &#10;    private static final String DB_NAME = &quot;librarydb&quot;;&#10;    private static final String MYSQL_URL_WITHOUT_DB = &quot;jdbc:mysql://localhost:3306/&quot;;&#10;    private static final String MYSQL_URL_WITH_DB = MYSQL_URL_WITHOUT_DB + DB_NAME;&#10;    private static final String USERNAME = &quot;root&quot;;&#10;    private static final String PASSWORD = &quot;1234&quot;;&#10;    &#10;    /**&#10;     *  INICIALIZA LA BASE DE DATOS COMPLETA&#10;     * &#10;     * 1. Verifica si MySQL está disponible&#10;     * 2. Crea la base de datos si no existe&#10;     * 3. Configura parámetros iniciales&#10;     */&#10;    public static void initializeDatabase() {&#10;        try {&#10;            Logger.info(&quot;DatabaseInitializer&quot;, &quot; Verificando conexión a MySQL...&quot;);&#10;            &#10;            // PASO 1: Verificar conexión a MySQL&#10;            if (!isMySQLAvailable()) {&#10;                throw new RuntimeException(&quot;❌ MySQL no está disponible en localhost:3306&quot;);&#10;            }&#10;            &#10;            // PASO 2: Crear base de datos si no existe&#10;            createDatabaseIfNotExists();&#10;            &#10;            // PASO 3: Verificar conexión a la BD específica&#10;            verifyDatabaseConnection();&#10;            &#10;            Logger.info(&quot;DatabaseInitializer&quot;, &quot;✅ Base de datos inicializada correctamente&quot;);&#10;            &#10;        } catch (Exception e) {&#10;            Logger.error(&quot;DatabaseInitializer&quot;, &quot;❌ Error al inicializar base de datos&quot;, e);&#10;            throw new RuntimeException(&quot;Error crítico en inicialización de BD&quot;, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     *  VERIFICA SI MYSQL ESTÁ DISPONIBLE&#10;     */&#10;    private static boolean isMySQLAvailable() {&#10;        try (Connection connection = DriverManager.getConnection(&#10;                MYSQL_URL_WITHOUT_DB + &quot;?allowPublicKeyRetrieval=true&amp;useSSL=false&quot;, &#10;                USERNAME, PASSWORD)) {&#10;            return connection != null;&#10;        } catch (SQLException e) {&#10;            Logger.error(&quot;DatabaseInitializer&quot;, &quot;MySQL no disponible&quot;, e);&#10;            return false;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * ️ CREA LA BASE DE DATOS SI NO EXISTE&#10;     */&#10;    private static void createDatabaseIfNotExists() throws SQLException {&#10;        String createDatabaseSQL = String.format(&#10;            &quot;CREATE DATABASE IF NOT EXISTS %s CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci&quot;, &#10;            DB_NAME&#10;        );&#10;        &#10;        try (Connection connection = DriverManager.getConnection(&#10;                MYSQL_URL_WITHOUT_DB + &quot;?allowPublicKeyRetrieval=true&amp;useSSL=false&quot;, &#10;                USERNAME, PASSWORD);&#10;             Statement statement = connection.createStatement()) {&#10;            &#10;            Logger.info(&quot;DatabaseInitializer&quot;, &quot;️ Creando base de datos si no existe...&quot;);&#10;            statement.executeUpdate(createDatabaseSQL);&#10;            Logger.info(&quot;DatabaseInitializer&quot;, &quot;✅ Base de datos '&quot; + DB_NAME + &quot;' disponible&quot;);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * ✅ VERIFICA CONEXIÓN A LA BASE DE DATOS ESPECÍFICA&#10;     */&#10;    private static void verifyDatabaseConnection() throws SQLException {&#10;        try (Connection connection = DriverManager.getConnection(&#10;                MYSQL_URL_WITH_DB + &quot;?allowPublicKeyRetrieval=true&amp;useSSL=false&quot;, &#10;                USERNAME, PASSWORD)) {&#10;            &#10;            if (connection != null &amp;&amp; !connection.isClosed()) {&#10;                Logger.info(&quot;DatabaseInitializer&quot;, &quot;✅ Conexión a '&quot; + DB_NAME + &quot;' verificada&quot;);&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     *  OBTIENE INFORMACIÓN DE LA BASE DE DATOS&#10;     */&#10;    public static void printDatabaseInfo() {&#10;        try (Connection connection = DriverManager.getConnection(&#10;                MYSQL_URL_WITH_DB + &quot;?allowPublicKeyRetrieval=true&amp;useSSL=false&quot;, &#10;                USERNAME, PASSWORD);&#10;             Statement statement = connection.createStatement()) {&#10;            &#10;            // Información básica&#10;            var metaData = connection.getMetaData();&#10;            Logger.info(&quot;DatabaseInitializer&quot;, &quot; Base de datos: &quot; + metaData.getDatabaseProductName());&#10;            Logger.info(&quot;DatabaseInitializer&quot;, &quot; Versión: &quot; + metaData.getDatabaseProductVersion());&#10;            Logger.info(&quot;DatabaseInitializer&quot;, &quot; Esquema: &quot; + DB_NAME);&#10;            &#10;        } catch (SQLException e) {&#10;            Logger.error(&quot;DatabaseInitializer&quot;, &quot;Error obteniendo info de BD&quot;, e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/db/JpaConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/db/JpaConfig.java" />
              <option name="originalContent" value="package com.libraryManagement.config.db;&#10;&#10;import jakarta.persistence.EntityManagerFactory;&#10;import jakarta.persistence.Persistence;&#10;&#10;/**&#10; *  Clase de configuración que inicializa y expone el EntityManagerFactory&#10; *  * de forma centralizada. Se utiliza para gestionar la conexión JPA con la base de datos.&#10; */&#10;public class JpaConfig {&#10;&#10;    // Instancia única y global de EntityManagerFactory&#10;    private static final EntityManagerFactory emf;&#10;&#10;    static {&#10;        try {&#10;            // Crea el EntityManagerFactory a partir del archivo persistence.xml&#10;            // El nombre 'libraryPU' debe coincidir con el persistence-unit definido&#10;            emf = Persistence.createEntityManagerFactory(&quot;libraryPU&quot;);&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot;❌ Error al inicializar EntityManagerFactory&quot;, e);&#10;        }&#10;    }&#10;&#10;   //Retorna la instancia de EntityManagerFactory&#10;    public static EntityManagerFactory getEntityManagerFactory() {&#10;        return emf;&#10;    }&#10;    //Cierra el EntityManagerFactory al finalizar la aplicación&#10;    public static void shutdown() {&#10;        if (emf.isOpen()) emf.close();&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.libraryManagement.config.db;&#10;&#10;import com.libraryManagement.util.Logger; // ← AGREGADO: Logger profesional&#10;import jakarta.persistence.EntityManagerFactory;&#10;import jakarta.persistence.Persistence;&#10;&#10;/**&#10; * Clase de configuración que inicializa y expone el EntityManagerFactory&#10; * de forma centralizada. Se utiliza para gestionar la conexión JPA con la base de datos.&#10; */&#10;public class JpaConfig {&#10;&#10;    // Instancia única y global de EntityManagerFactory&#10;    private static final EntityManagerFactory emf;&#10;&#10;    static {&#10;        try {&#10;            Logger.debug(&quot;JpaConfig&quot;, &quot;Inicializando EntityManagerFactory...&quot;);&#10;            // Crea el EntityManagerFactory a partir del archivo persistence.xml&#10;            // El nombre 'libraryPU' debe coincidir con el persistence-unit definido&#10;            emf = Persistence.createEntityManagerFactory(&quot;libraryPU&quot;);&#10;            Logger.success(&quot;JpaConfig&quot;, &quot;EntityManagerFactory inicializado correctamente&quot;);&#10;        } catch (Exception e) {&#10;            Logger.error(&quot;JpaConfig&quot;, &quot;Error al inicializar EntityManagerFactory&quot;, e);&#10;            throw new RuntimeException(&quot;❌ Error al inicializar EntityManagerFactory&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Retorna la instancia de EntityManagerFactory&#10;     */&#10;    public static EntityManagerFactory getEntityManagerFactory() {&#10;        return emf;&#10;    }&#10;&#10;    /**&#10;     * Cierra el EntityManagerFactory al finalizar la aplicación&#10;     */&#10;    public static void shutdown() {&#10;        if (emf != null &amp;&amp; emf.isOpen()) {&#10;            Logger.info(&quot;JpaConfig&quot;, &quot;Cerrando EntityManagerFactory...&quot;);&#10;            emf.close();&#10;            Logger.info(&quot;JpaConfig&quot;, &quot;EntityManagerFactory cerrado&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/db/TransactionUtil.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/db/TransactionUtil.java" />
              <option name="originalContent" value="package com.libraryManagement.config.db;&#10;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityTransaction;&#10;&#10;import java.util.function.Consumer;&#10;import java.util.function.Function;&#10;&#10;/**&#10; * Utilidad para manejar transacciones de forma sencilla.&#10; * Permite ejecutar acciones dentro de una transacción&#10; * y manejar errores de forma centralizada.&#10; */&#10;public class TransactionUtil {&#10;    /**&#10;     * Ejecuta una acción con EntityManager dentro de una transacción.&#10;     * Se recomienda para operaciones como persistencia, actualizaciones o eliminación.&#10;     */&#10;    public static void executeInTransaction(Consumer&lt;EntityManager&gt; action){&#10;        EntityManager em = PersistenceManager.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try{&#10;            tx.begin();// Inicia la transacción&#10;            action.accept(em);// Ejecuta la acción principal&#10;            tx.commit(); // Confirma los cambios&#10;        }catch (Exception e){&#10;            if(tx.isActive()) tx.rollback();// Revierte en caso de error&#10;            throw  new RuntimeException(&quot; -- Transacción fallida&quot;, e);&#10;        }finally {&#10;            if(em.isOpen()) em.close();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Ejecuta una función con EntityManager dentro de una transacción y retorna un resultado.&#10;     */&#10;    public static &lt;T&gt; T executeInTransactionWithResult(Function&lt;EntityManager, T&gt; function) {&#10;        EntityManager em = PersistenceManager.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try {&#10;            tx.begin(); // Inicia la transacción&#10;            T result = function.apply(em); // Ejecuta la función y obtiene el resultado&#10;            tx.commit(); // Confirma los cambios&#10;            return result; // Retorna el resultado&#10;        } catch (Exception e) {&#10;            if (tx.isActive()) tx.rollback(); // Revierte en caso de error&#10;            throw new RuntimeException(&quot; -- Transacción fallida&quot;, e);&#10;        } finally {&#10;            if (em.isOpen()) em.close();&#10;        }&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.libraryManagement.config.db;&#10;&#10;import com.libraryManagement.util.Logger; // ← AGREGADO: Logger profesional&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityTransaction;&#10;&#10;import java.util.function.Consumer;&#10;import java.util.function.Function;&#10;&#10;/**&#10; * Utilidad para manejar transacciones de forma sencilla.&#10; * Permite ejecutar acciones dentro de una transacción&#10; * y manejar errores de forma centralizada.&#10; */&#10;public class TransactionUtil {&#10;    /**&#10;     * Ejecuta una acción con EntityManager dentro de una transacción.&#10;     * Se recomienda para operaciones como persistencia, actualizaciones o eliminación.&#10;     */&#10;    public static void executeInTransaction(Consumer&lt;EntityManager&gt; action){&#10;        EntityManager em = PersistenceManager.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try{&#10;            tx.begin();// Inicia la transacción&#10;            action.accept(em);// Ejecuta la acción principal&#10;            tx.commit(); // Confirma los cambios&#10;            Logger.debug(&quot;TransactionUtil&quot;, &quot;Transacción completada exitosamente&quot;);&#10;        }catch (Exception e){&#10;            if(tx.isActive()) {&#10;                tx.rollback();// Revierte en caso de error&#10;                Logger.warn(&quot;TransactionUtil&quot;, &quot;Transacción revertida debido a error: &quot; + e.getMessage());&#10;            }&#10;            Logger.error(&quot;TransactionUtil&quot;, &quot;Transacción fallida&quot;, e);&#10;            throw new RuntimeException(&quot;Transacción fallida&quot;, e);&#10;        }finally {&#10;            if(em.isOpen()) em.close();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Ejecuta una función con EntityManager y retorna un resultado dentro de una transacción.&#10;     * Se recomienda para consultas complejas que necesitan transacción.&#10;     */&#10;    public static &lt;T&gt; T executeInTransactionWithResult(Function&lt;EntityManager, T&gt; function){&#10;        EntityManager em = PersistenceManager.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try{&#10;            tx.begin();&#10;            T result = function.apply(em);&#10;            tx.commit();&#10;            Logger.debug(&quot;TransactionUtil&quot;, &quot;Transacción con resultado completada exitosamente&quot;);&#10;            return result;&#10;        }catch (Exception e){&#10;            if(tx.isActive()) {&#10;                tx.rollback();&#10;                Logger.warn(&quot;TransactionUtil&quot;, &quot;Transacción con resultado revertida: &quot; + e.getMessage());&#10;            }&#10;            Logger.error(&quot;TransactionUtil&quot;, &quot;Transacción con resultado fallida&quot;, e);&#10;            throw new RuntimeException(&quot;Transacción fallida&quot;, e);&#10;        }finally {&#10;            if(em.isOpen()) em.close();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/dependency/DependencyContainer.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/dependency/DependencyContainer.java" />
              <option name="originalContent" value="package com.libraryManagement.config.dependency;&#10;&#10;import com.libraryManagement.repository.impl.UserRepositoryImpl;&#10;import com.libraryManagement.repository.interfaces.UserRepository;&#10;import com.libraryManagement.service.UserServiceImpl;&#10;import com.libraryManagement.service.interfaces.UserService;&#10;import com.libraryManagement.controller.UserController;&#10;import com.libraryManagement.mapper.UserMapper;&#10;import com.libraryManagement.mapper.factory.MapperFactory;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * CONTENEDOR DE DEPENDENCIAS ESCALABLE&#10; * Estructura profesional que soporta múltiples entidades sin explotar en complejidad&#10; */&#10;public class DependencyContainer {&#10;&#10;    // =====================================================================&#10;    // ALMACENAMIENTO GENÉRICO POR TIPO&#10;    // =====================================================================&#10;&#10;    private final Map&lt;Class&lt;?&gt;, Object&gt; repositories = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Object&gt; services = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Object&gt; mappers = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Object&gt; controllers = new HashMap&lt;&gt;();&#10;&#10;    private MapperFactory mapperFactory;&#10;&#10;    // =====================================================================&#10;    // INICIALIZACIÓN MODULAR&#10;    // =====================================================================&#10;&#10;    public void initializeDependencies() {&#10;        // 1. Inicializar Factory de Mappers&#10;        initializeMapperFactory();&#10;&#10;        // 2. Inicializar por módulos&#10;        initializeUserModule();&#10;        // initializeBookModule();    // Futuro&#10;        // initializeLoanModule();    // Futuro&#10;&#10;        System.out.println(&quot;✅ Dependencias inicializadas correctamente&quot;);&#10;    }&#10;&#10;    private void initializeMapperFactory() {&#10;        mapperFactory = MapperFactory.getInstance();&#10;    }&#10;&#10;    /**&#10;     * MÓDULO USER - Agrupa todas las dependencias de User&#10;     */&#10;    private void initializeUserModule() {&#10;        // Mappers&#10;        var userMapper = mapperFactory.getMapper(UserMapper.class);&#10;        mappers.put(UserMapper.class, userMapper);&#10;&#10;        // Repositories&#10;        var userRepository = new UserRepositoryImpl();&#10;        repositories.put(UserRepository.class, userRepository);&#10;&#10;        // Services - ✅ DECLARAR COMO INTERFACE&#10;        UserService userService = new UserServiceImpl((UserRepository) userRepository,&#10;            userMapper&#10;        );&#10;        services.put(UserService.class, userService);&#10;&#10;        // Controllers&#10;        var userController = new UserController(userService);&#10;        controllers.put(UserController.class, userController);&#10;&#10;        System.out.println(&quot; User module initialized&quot;);&#10;    }&#10;&#10;    // =====================================================================&#10;    // ACCESO GENÉRICO Y TIPADO&#10;    // =====================================================================&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; T getRepository(Class&lt;T&gt; repositoryClass) {&#10;        return (T) repositories.get(repositoryClass);&#10;    }&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; T getService(Class&lt;T&gt; serviceClass) {&#10;        return (T) services.get(serviceClass);&#10;    }&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; T getController(Class&lt;T&gt; controllerClass) {&#10;        return (T) controllers.get(controllerClass);&#10;    }&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; T getMapper(Class&lt;T&gt; mapperClass) {&#10;        return (T) mappers.get(mapperClass);&#10;    }&#10;&#10;    public MapperFactory getMapperFactory() {&#10;        return mapperFactory;&#10;    }&#10;&#10;    public void shutdown() {&#10;        repositories.clear();&#10;        services.clear();&#10;        mappers.clear();&#10;        controllers.clear();&#10;        System.out.println(&quot; Dependencias liberadas&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.libraryManagement.config.dependency;&#10;&#10;import com.libraryManagement.repository.impl.UserRepositoryImpl;&#10;import com.libraryManagement.repository.interfaces.UserRepository;&#10;import com.libraryManagement.service.UserServiceImpl;&#10;import com.libraryManagement.service.interfaces.UserService;&#10;import com.libraryManagement.controller.UserController;&#10;import com.libraryManagement.mapper.UserMapper;&#10;import com.libraryManagement.mapper.factory.MapperFactory;&#10;import com.libraryManagement.util.Logger; // ← AGREGADO: Logger profesional&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * CONTENEDOR DE DEPENDENCIAS ESCALABLE&#10; * Estructura profesional que soporta múltiples entidades sin explotar en complejidad&#10; */&#10;public class DependencyContainer {&#10;&#10;    // =====================================================================&#10;    // ALMACENAMIENTO GENÉRICO POR TIPO&#10;    // =====================================================================&#10;&#10;    private final Map&lt;Class&lt;?&gt;, Object&gt; repositories = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Object&gt; services = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Object&gt; mappers = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Object&gt; controllers = new HashMap&lt;&gt;();&#10;&#10;    private MapperFactory mapperFactory;&#10;&#10;    // =====================================================================&#10;    // INICIALIZACIÓN MODULAR&#10;    // =====================================================================&#10;&#10;    public void initializeDependencies() {&#10;        // 1. Inicializar Factory de Mappers&#10;        initializeMapperFactory();&#10;&#10;        // 2. Inicializar por módulos&#10;        initializeUserModule();&#10;        // initializeBookModule();    // Futuro&#10;        // initializeLoanModule();    // Futuro&#10;&#10;        Logger.success(&quot;DependencyContainer&quot;, &quot;Dependencias inicializadas correctamente&quot;);&#10;    }&#10;&#10;    private void initializeMapperFactory() {&#10;        Logger.info(&quot;DependencyContainer&quot;, &quot;Inicializando mappers...&quot;);&#10;        mapperFactory = MapperFactory.getInstance();&#10;        Logger.success(&quot;DependencyContainer&quot;, &quot;Todos los mappers inicializados&quot;);&#10;    }&#10;&#10;    /**&#10;     * MÓDULO USER - Agrupa todas las dependencias de User&#10;     */&#10;    private void initializeUserModule() {&#10;        // Mappers&#10;        var userMapper = mapperFactory.getMapper(UserMapper.class);&#10;        mappers.put(UserMapper.class, userMapper);&#10;&#10;        // Repositories&#10;        var userRepository = new UserRepositoryImpl();&#10;        repositories.put(UserRepository.class, userRepository);&#10;&#10;        // Services - ✅ DECLARAR COMO INTERFACE&#10;        UserService userService = new UserServiceImpl((UserRepository) userRepository,&#10;            userMapper&#10;        );&#10;        services.put(UserService.class, userService);&#10;&#10;        // Controllers&#10;        var userController = new UserController(userService);&#10;        controllers.put(UserController.class, userController);&#10;&#10;        Logger.success(&quot;DependencyContainer&quot;, &quot;User module initialized&quot;);&#10;    }&#10;&#10;    // =====================================================================&#10;    // ACCESO GENÉRICO Y TIPADO&#10;    // =====================================================================&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; T getRepository(Class&lt;T&gt; repositoryClass) {&#10;        return (T) repositories.get(repositoryClass);&#10;    }&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; T getService(Class&lt;T&gt; serviceClass) {&#10;        return (T) services.get(serviceClass);&#10;    }&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; T getController(Class&lt;T&gt; controllerClass) {&#10;        return (T) controllers.get(controllerClass);&#10;    }&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; T getMapper(Class&lt;T&gt; mapperClass) {&#10;        return (T) mappers.get(mapperClass);&#10;    }&#10;&#10;    public MapperFactory getMapperFactory() {&#10;        return mapperFactory;&#10;    }&#10;&#10;    public void shutdown() {&#10;        repositories.clear();&#10;        services.clear();&#10;        mappers.clear();&#10;        controllers.clear();&#10;        Logger.info(&quot;DependencyContainer&quot;, &quot;Dependencias liberadas&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/server/RouteRegistry.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/server/RouteRegistry.java" />
              <option name="originalContent" value="package com.libraryManagement.config.server;&#10;&#10;import com.sun.net.httpserver.HttpServer;&#10;import com.libraryManagement.controller.UserController;&#10;&#10;/**&#10; * Registro centralizado de rutas y endpoints&#10; * Responsabilidad: Mapear URLs a controladores específicos&#10; */&#10;public class RouteRegistry {&#10;&#10;    private final HttpServer server;&#10;&#10;    public RouteRegistry(HttpServer server) {&#10;        this.server = server;&#10;    }&#10;&#10;    /**&#10;     * Registra todas las rutas de la aplicación&#10;     * @param userController el controlador de usuarios&#10;     */&#10;    public void registerRoutes(UserController userController) {&#10;        // Rutas de usuarios&#10;        registerUserRoutes(userController);&#10;&#10;        // Ruta de health check&#10;        registerHealthCheck();&#10;&#10;        // Aquí se agregarán más rutas cuando se creen otros controladores&#10;        // registerBookRoutes(bookController);&#10;        // registerLoanRoutes(loanController);&#10;    }&#10;&#10;    /**&#10;     * Registra las rutas específicas de usuarios&#10;     */&#10;    private void registerUserRoutes(UserController userController) {&#10;        server.createContext(&quot;/api/users&quot;, userController);&#10;&#10;        // Rutas adicionales si las necesitas:&#10;        // server.createContext(&quot;/api/users/search&quot;, userController);&#10;        // server.createContext(&quot;/api/users/statistics&quot;, userController);&#10;    }&#10;&#10;    /**&#10;     * Registra endpoint de health check para monitoreo&#10;     */&#10;    private void registerHealthCheck() {&#10;        server.createContext(&quot;/health&quot;, exchange -&gt; {&#10;            String response = &quot;{\&quot;status\&quot;:\&quot;UP\&quot;,\&quot;service\&quot;:\&quot;Library Management API\&quot;}&quot;;&#10;            exchange.getResponseHeaders().set(&quot;Content-Type&quot;, &quot;application/json&quot;);&#10;            exchange.sendResponseHeaders(200, response.getBytes().length);&#10;            exchange.getResponseBody().write(response.getBytes());&#10;            exchange.getResponseBody().close();&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Obtiene información sobre las rutas registradas&#10;     */&#10;    public void printRegisteredRoutes() {&#10;        System.out.println(&quot; Rutas registradas:&quot;);&#10;        System.out.println(&quot;   GET/POST/PUT/DELETE /api/users - Gestión de usuarios&quot;);&#10;        System.out.println(&quot;   GET /health - Health check&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.libraryManagement.config.server;&#13;&#10;&#13;&#10;import com.libraryManagement.util.Logger; // ← AGREGADO: Logger profesional&#13;&#10;import com.sun.net.httpserver.HttpServer;&#13;&#10;import com.libraryManagement.controller.UserController;&#13;&#10;&#13;&#10;/**&#13;&#10; * Registro centralizado de rutas y endpoints&#13;&#10; * Responsabilidad: Mapear URLs a controladores específicos&#13;&#10; */&#13;&#10;public class RouteRegistry {&#13;&#10;&#13;&#10;    private final HttpServer server;&#13;&#10;&#13;&#10;    public RouteRegistry(HttpServer server) {&#13;&#10;        this.server = server;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Registra todas las rutas de usuarios&#13;&#10;     */&#13;&#10;    public void registerUserRoutes(UserController userController) {&#13;&#10;        Logger.debug(&quot;RouteRegistry&quot;, &quot;Registrando rutas de usuarios...&quot;);&#13;&#10;        server.createContext(&quot;/api/users&quot;, userController);&#13;&#10;        Logger.info(&quot;RouteRegistry&quot;, &quot;Rutas de usuarios registradas en /api/users&quot;);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Registra endpoint de health check para monitoreo&#13;&#10;     */&#13;&#10;    public void registerHealthCheck() {&#13;&#10;        Logger.debug(&quot;RouteRegistry&quot;, &quot;Registrando health check...&quot;);&#13;&#10;        server.createContext(&quot;/health&quot;, exchange -&gt; {&#13;&#10;            String response = &quot;{\&quot;status\&quot;:\&quot;UP\&quot;,\&quot;service\&quot;:\&quot;Library Management API\&quot;}&quot;;&#13;&#10;            exchange.getResponseHeaders().set(&quot;Content-Type&quot;, &quot;application/json&quot;);&#13;&#10;            exchange.sendResponseHeaders(200, response.getBytes().length);&#13;&#10;            exchange.getResponseBody().write(response.getBytes());&#13;&#10;            exchange.getResponseBody().close();&#13;&#10;        });&#13;&#10;        Logger.info(&quot;RouteRegistry&quot;, &quot;Health check registrado en /health&quot;);&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/server/ServerConfiguration.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/server/ServerConfiguration.java" />
              <option name="originalContent" value="package com.libraryManagement.config.server;&#10;&#10;import com.sun.net.httpserver.HttpServer;&#10;import java.io.IOException;&#10;import java.net.InetSocketAddress;&#10;import java.util.concurrent.Executors;&#10;&#10;/**&#10; * Configuración del servidor HTTP&#10; * Responsabilidad: Crear y configurar el servidor HTTP con sus parámetros&#10; */&#10;public class ServerConfiguration {&#10;&#10;    private static final int DEFAULT_PORT = 8080;&#10;    private static final int DEFAULT_BACKLOG = 0; // Sin límite de conexiones pendientes&#10;    private static final int THREAD_POOL_SIZE = 10;&#10;&#10;    private final int port;&#10;    private final int backlog;&#10;    private final int threadPoolSize;&#10;&#10;    // Constructor con valores por defecto&#10;    public ServerConfiguration() {&#10;        this(DEFAULT_PORT, DEFAULT_BACKLOG, THREAD_POOL_SIZE);&#10;    }&#10;&#10;    // Constructor personalizable&#10;    public ServerConfiguration(int port, int backlog, int threadPoolSize) {&#10;        this.port = port;&#10;        this.backlog = backlog;&#10;        this.threadPoolSize = threadPoolSize;&#10;    }&#10;&#10;    /**&#10;     * Crea y configura el servidor HTTP&#10;     * @return HttpServer configurado pero no iniciado&#10;     * @throws IOException si hay error al crear el servidor&#10;     */&#10;    public HttpServer createServer() throws IOException {&#10;        // Crear el servidor HTTP en la dirección y puerto especificados&#10;        HttpServer server = HttpServer.create(new InetSocketAddress(port), backlog);&#10;&#10;        // Configurar pool de hilos para manejar requests concurrentes&#10;        server.setExecutor(Executors.newFixedThreadPool(threadPoolSize));&#10;&#10;        return server;&#10;    }&#10;&#10;    // Getters para acceso a configuración&#10;    public int getPort() { return port; }&#10;    public int getBacklog() { return backlog; }&#10;    public int getThreadPoolSize() { return threadPoolSize; }&#10;}&#10;" />
              <option name="updatedContent" value="package com.libraryManagement.config.server;&#13;&#10;&#13;&#10;import com.libraryManagement.util.Logger; // ← AGREGADO: Logger profesional&#13;&#10;import com.sun.net.httpserver.HttpServer;&#13;&#10;import java.io.IOException;&#13;&#10;import java.net.InetSocketAddress;&#13;&#10;import java.util.concurrent.Executors;&#13;&#10;&#13;&#10;/**&#13;&#10; * Configuración del servidor HTTP&#13;&#10; * Responsabilidad: Crear y configurar el servidor HTTP con sus parámetros&#13;&#10; */&#13;&#10;public class ServerConfiguration {&#13;&#10;&#13;&#10;    private static final int DEFAULT_PORT = 8080;&#13;&#10;    private static final int DEFAULT_BACKLOG = 0; // Sin límite de conexiones pendientes&#13;&#10;    private static final int THREAD_POOL_SIZE = 10;&#13;&#10;&#13;&#10;    private final int port;&#13;&#10;    private final int backlog;&#13;&#10;    private final int threadPoolSize;&#13;&#10;&#13;&#10;    // Constructor con valores por defecto&#13;&#10;    public ServerConfiguration() {&#13;&#10;        this(DEFAULT_PORT, DEFAULT_BACKLOG, THREAD_POOL_SIZE);&#13;&#10;    }&#13;&#10;&#13;&#10;    // Constructor personalizable&#13;&#10;    public ServerConfiguration(int port, int backlog, int threadPoolSize) {&#13;&#10;        this.port = port;&#13;&#10;        this.backlog = backlog;&#13;&#10;        this.threadPoolSize = threadPoolSize;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Crea y configura el servidor HTTP&#13;&#10;     */&#13;&#10;    public HttpServer createServer() throws IOException {&#13;&#10;        try {&#13;&#10;            Logger.debug(&quot;ServerConfiguration&quot;, &quot;Creando servidor en puerto &quot; + port);&#13;&#10;            &#13;&#10;            HttpServer server = HttpServer.create(new InetSocketAddress(port), backlog);&#13;&#10;            &#13;&#10;            // Configurar pool de threads&#13;&#10;            server.setExecutor(Executors.newFixedThreadPool(threadPoolSize));&#13;&#10;            &#13;&#10;            Logger.success(&quot;ServerConfiguration&quot;, &quot;Servidor HTTP creado exitosamente - Puerto: &quot; + port + &quot;, Threads: &quot; + threadPoolSize);&#13;&#10;            return server;&#13;&#10;            &#13;&#10;        } catch (IOException e) {&#13;&#10;            Logger.error(&quot;ServerConfiguration&quot;, &quot;Error creando servidor HTTP en puerto &quot; + port, e);&#13;&#10;            throw e;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Getters&#13;&#10;    public int getPort() { return port; }&#13;&#10;    public int getBacklog() { return backlog; }&#13;&#10;    public int getThreadPoolSize() { return threadPoolSize; }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/domain/user/UserUtils.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/domain/user/UserUtils.java" />
              <option name="updatedContent" value="package com.libraryManagement.domain.user;&#10;&#10;import com.libraryManagement.model.User;&#10;import com.libraryManagement.model.Address;&#10;import java.time.LocalDate;&#10;import java.time.Period;&#10;&#10;/**&#10; * UTILIDADES ESPECÍFICAS DEL DOMINIO USER&#10; * &#10; * Solo contiene cálculos y transformaciones específicas&#10; * de la entidad User que NO son validaciones de negocio&#10; */&#10;public class UserUtils {&#10;&#10;    /**&#10;     * Calcula la edad basada en fecha de nacimiento&#10;     */&#10;    public static Integer calculateAge(LocalDate dateOfBirth) {&#10;        if (dateOfBirth == null) {&#10;            return null;&#10;        }&#10;&#10;        LocalDate now = LocalDate.now();&#10;        if (dateOfBirth.isAfter(now)) {&#10;            return 0; // Fecha futura = 0 años&#10;        }&#10;&#10;        return Period.between(dateOfBirth, now).getYears();&#10;    }&#10;&#10;    /**&#10;     * Extrae el nombre de ciudad de una dirección&#10;     */&#10;    public static String extractCityName(Address address) {&#10;        if (address == null) {&#10;            return null;&#10;        }&#10;        return address.getCity();&#10;    }&#10;&#10;    /**&#10;     * Formatea nombre completo del usuario&#10;     */&#10;    public static String formatFullName(String firstName, String lastName) {&#10;        if (firstName == null &amp;&amp; lastName == null) {&#10;            return &quot;Nombre no disponible&quot;;&#10;        }&#10;        &#10;        String first = firstName != null ? firstName.trim() : &quot;&quot;;&#10;        String last = lastName != null ? lastName.trim() : &quot;&quot;;&#10;        &#10;        if (first.isEmpty() &amp;&amp; last.isEmpty()) {&#10;            return &quot;Nombre no disponible&quot;;&#10;        }&#10;        &#10;        return (first + &quot; &quot; + last).trim();&#10;    }&#10;&#10;    /**&#10;     * Calcula estado de membresía basado en el estado del usuario&#10;     * &#10;     * NOTA: Este es un cálculo, no una validación de negocio&#10;     */&#10;    public static String calculateMembershipStatus(User user) {&#10;        if (user == null || user.getLoans() == null) {&#10;            return &quot;ACTIVE&quot;;&#10;        }&#10;&#10;        // Contar préstamos activos&#10;        long activeLoans = user.getLoans().stream()&#10;            .filter(loan -&gt; loan.getReturnedAt() == null)&#10;            .count();&#10;&#10;        // Verificar préstamos vencidos&#10;        boolean hasOverdueLoans = user.getLoans().stream()&#10;            .filter(loan -&gt; loan.getReturnedAt() == null)&#10;            .anyMatch(loan -&gt; loan.getDueDate().isBefore(LocalDate.now()));&#10;&#10;        if (hasOverdueLoans) {&#10;            return &quot;SUSPENDED&quot;;&#10;        } else if (activeLoans &gt;= 3) {&#10;            return &quot;LIMITED&quot;;&#10;        } else {&#10;            return &quot;ACTIVE&quot;;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/exception/response/ErrorResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/exception/response/ErrorResponse.java" />
              <option name="originalContent" value="package com.libraryManagement.exception.response;&#10;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import com.fasterxml.jackson.annotation.JsonFormat;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;/**&#10; * RESPUESTA ESTÁNDAR DE ERROR&#10; *&#10; * Estructura unificada para todas las respuestas de error de la API&#10; */&#10;@Data&#10;@Builder&#10;public class ErrorResponse {&#10;&#10;    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)&#10;    private LocalDateTime timestamp;&#10;&#10;    private int status;&#10;    private String error;&#10;    private String message;&#10;    private String operation;&#10;    private String path;&#10;&#10;    /**&#10;     * Crear respuesta de error simple&#10;     */&#10;    public static ErrorResponse simple(String message, int status) {&#10;        return ErrorResponse.builder()&#10;            .timestamp(LocalDateTime.now())&#10;            .status(status)&#10;            .error(getHttpStatusText(status))&#10;            .message(message)&#10;            .build();&#10;    }&#10;&#10;    /**&#10;     * Crear respuesta de error completa&#10;     */&#10;    public static ErrorResponse complete(String message, int status, String operation, String path) {&#10;        return ErrorResponse.builder()&#10;            .timestamp(LocalDateTime.now())&#10;            .status(status)&#10;            .error(getHttpStatusText(status))&#10;            .message(message)&#10;            .operation(operation)&#10;            .path(path)&#10;            .build();&#10;    }&#10;&#10;    private static String getHttpStatusText(int status) {&#10;        return switch (status) {&#10;            case 400 -&gt; &quot;Bad Request&quot;;&#10;            case 401 -&gt; &quot;Unauthorized&quot;;&#10;            case 403 -&gt; &quot;Forbidden&quot;;&#10;            case 404 -&gt; &quot;Not Found&quot;;&#10;            case 409 -&gt; &quot;Conflict&quot;;&#10;            case 422 -&gt; &quot;Unprocessable Entity&quot;;&#10;            case 500 -&gt; &quot;Internal Server Error&quot;;&#10;            default -&gt; &quot;Error&quot;;&#10;        };&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.libraryManagement.exception.response;&#13;&#10;&#13;&#10;import lombok.Builder;&#13;&#10;import lombok.Data;&#13;&#10;import com.fasterxml.jackson.annotation.JsonFormat;&#13;&#10;&#13;&#10;import java.time.LocalDateTime;&#13;&#10;&#13;&#10;/**&#13;&#10; * RESPUESTA ESTÁNDAR DE ERROR&#13;&#10; *&#13;&#10; * Estructura unificada para todas las respuestas de error de la API&#13;&#10; */&#13;&#10;@Data&#13;&#10;@Builder&#13;&#10;public class ErrorResponse {&#13;&#10;&#13;&#10;    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)&#13;&#10;    private LocalDateTime timestamp;&#13;&#10;&#13;&#10;    private int status;&#13;&#10;    private String error;&#13;&#10;    private String message;&#13;&#10;    private String operation;&#13;&#10;    private String path;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Crear respuesta de error simple&#13;&#10;     */&#13;&#10;    public static ErrorResponse simple(String message, int status) {&#13;&#10;        return ErrorResponse.builder()&#13;&#10;            .timestamp(LocalDateTime.now())&#13;&#10;            .status(status)&#13;&#10;            .error(getHttpStatusText(status))&#13;&#10;            .message(message)&#13;&#10;            .build();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Crear respuesta de error completa&#13;&#10;     */&#13;&#10;    public static ErrorResponse complete(String message, int status, String operation, String path) {&#13;&#10;        return ErrorResponse.builder()&#13;&#10;            .timestamp(LocalDateTime.now())&#13;&#10;            .status(status)&#13;&#10;            .error(getHttpStatusText(status))&#13;&#10;            .message(message)&#13;&#10;            .operation(operation)&#13;&#10;            .path(path)&#13;&#10;            .build();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Convierte código HTTP a texto descriptivo&#13;&#10;     */&#13;&#10;    private static String getHttpStatusText(int status) {&#13;&#10;        return switch (status) {&#13;&#10;            case 400 -&gt; &quot;Bad Request&quot;;&#13;&#10;            case 401 -&gt; &quot;Unauthorized&quot;;&#13;&#10;            case 403 -&gt; &quot;Forbidden&quot;;&#13;&#10;            case 404 -&gt; &quot;Not Found&quot;;&#13;&#10;            case 409 -&gt; &quot;Conflict&quot;;&#13;&#10;            case 422 -&gt; &quot;Unprocessable Entity&quot;;&#13;&#10;            case 500 -&gt; &quot;Internal Server Error&quot;;&#13;&#10;            case 503 -&gt; &quot;Service Unavailable&quot;;&#13;&#10;            default -&gt; &quot;Error&quot;;&#13;&#10;        };&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/mapper/context/UserMappingContext.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/mapper/context/UserMappingContext.java" />
              <option name="originalContent" value="package com.libraryManagement.mapper.context;&#10;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;&#10;/**&#10; * CONTEXTO ESPECÍFICO PARA USER&#10; * Utiliza el BaseMappingContext existente como base&#10; */&#10;@Data&#10;@Builder&#10;public class UserMappingContext {&#10;&#10;    // =====================================================================&#10;    // FACTORY METHODS - CONTEXTOS PREDEFINIDOS PARA USER&#10;    // =====================================================================&#10;&#10;    public static BaseMappingContext basic() {&#10;        return BaseMappingContext.builder()&#10;                .includeCalculatedFields(false)&#10;                .includeAddress(false)&#10;                .includeLoans(false)&#10;                .build();&#10;    }&#10;&#10;    public static BaseMappingContext withAddress() {&#10;        return BaseMappingContext.builder()&#10;                .includeCalculatedFields(true)&#10;                .includeAddress(true)&#10;                .includeLoans(false)&#10;                .build();&#10;    }&#10;&#10;    public static BaseMappingContext profile() {&#10;        return BaseMappingContext.builder()&#10;                .includeCalculatedFields(true)&#10;                .includeAddress(true)&#10;                .includeLoanStats(true)&#10;                .includeLoans(false)&#10;                .build();&#10;    }&#10;&#10;    public static BaseMappingContext admin() {&#10;        return BaseMappingContext.builder()&#10;                .includeCalculatedFields(true)&#10;                .includeAddress(true)&#10;                .includeLoans(true)&#10;                .includeLoanStats(true)&#10;                .includeFullDetails(true)&#10;                .build();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.libraryManagement.mapper.context;&#13;&#10;&#13;&#10;import lombok.Builder;&#13;&#10;import lombok.Data;&#13;&#10;&#13;&#10;/**&#13;&#10; * CONTEXTO ESPECÍFICO PARA USER&#13;&#10; * Utiliza el BaseMappingContext existente como base&#13;&#10; */&#13;&#10;@Data&#13;&#10;@Builder&#13;&#10;public class UserMappingContext {&#13;&#10;&#13;&#10;    // =====================================================================&#13;&#10;    // FACTORY METHODS - CONTEXTOS PREDEFINIDOS PARA USER&#13;&#10;    // =====================================================================&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Contexto simple - solo datos básicos sin relaciones&#13;&#10;     */&#13;&#10;    public static BaseMappingContext simple() {&#13;&#10;        return BaseMappingContext.builder()&#13;&#10;                .includeCalculatedFields(false)&#13;&#10;                .includeAddress(false)&#13;&#10;                .includeLoans(false)&#13;&#10;                .includeLoanStats(false)&#13;&#10;                .includeFullDetails(false)&#13;&#10;                .build();&#13;&#10;    }&#13;&#10;&#13;&#10;    public static BaseMappingContext basic() {&#13;&#10;        return BaseMappingContext.builder()&#13;&#10;                .includeCalculatedFields(false)&#13;&#10;                .includeAddress(false)&#13;&#10;                .includeLoans(false)&#13;&#10;                .build();&#13;&#10;    }&#13;&#10;&#13;&#10;    public static BaseMappingContext withAddress() {&#13;&#10;        return BaseMappingContext.builder()&#13;&#10;                .includeCalculatedFields(true)&#13;&#10;                .includeAddress(true)&#13;&#10;                .includeLoans(false)&#13;&#10;                .build();&#13;&#10;    }&#13;&#10;&#13;&#10;    public static BaseMappingContext profile() {&#13;&#10;        return BaseMappingContext.builder()&#13;&#10;                .includeCalculatedFields(true)&#13;&#10;                .includeAddress(true)&#13;&#10;                .includeLoanStats(true)&#13;&#10;                .includeLoans(false)&#13;&#10;                .build();&#13;&#10;    }&#13;&#10;&#13;&#10;    public static BaseMappingContext admin() {&#13;&#10;        return BaseMappingContext.builder()&#13;&#10;                .includeCalculatedFields(true)&#13;&#10;                .includeAddress(true)&#13;&#10;                .includeLoans(true)&#13;&#10;                .includeLoanStats(true)&#13;&#10;                .includeFullDetails(true)&#13;&#10;                .build();&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/repository/impl/UserRepositoryImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/repository/impl/UserRepositoryImpl.java" />
              <option name="originalContent" value="package com.libraryManagement.repository.impl;&#10;&#10;import com.libraryManagement.config.db.TransactionUtil;&#10;import com.libraryManagement.exception.repository.RepositoryException;&#10;import com.libraryManagement.model.User;&#10;import com.libraryManagement.repository.interfaces.UserRepository;&#10;import jakarta.persistence.NoResultException;&#10;import jakarta.persistence.TypedQuery;&#10;&#10;import java.time.LocalDate;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;/**&#10; * IMPLEMENTACIÓN PROFESIONAL DE UserRepository&#10; * USANDO JPA + TransactionUtil OPTIMIZADO&#10; *&#10; * Orden de métodos:&#10; * 1. Métodos de GenericRepository (CRUD básico)&#10; * 2. Métodos específicos de UserRepository (en orden de interface)&#10; */&#10;public class UserRepositoryImpl implements UserRepository {&#10;&#10;    // =====================================================================&#10;    // MÉTODOS DE GENERIC REPOSITORY - CON JPA + TransactionUtil OPTIMIZADO&#10;    // =====================================================================&#10;&#10;    @Override&#10;    public User save(User user) {&#10;        try {&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    return em.merge(user);&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error al guardar usuario&quot;, &quot;SAVE&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado al guardar usuario&quot;, &quot;SAVE&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Optional&lt;User&gt; findById(Long id) {&#10;        try {&#10;            User user = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    return em.find(User.class, id);&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error consultando usuario por ID: &quot; + id, &quot;FIND&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;            return Optional.ofNullable(user);&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado consultando usuario por ID: &quot; + id, &quot;FIND&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;User&gt; findAll() {&#10;        try {&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#10;                        &quot;SELECT u FROM User u ORDER BY u.lastName, u.firstName&quot;, User.class);&#10;                    return query.getResultList();&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error consultando todos los usuarios&quot;, &quot;FIND_ALL&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado consultando todos los usuarios&quot;, &quot;FIND_ALL&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void update(User user) {&#10;        try {&#10;            TransactionUtil.executeInTransaction(em -&gt; {&#10;                try {&#10;                    em.merge(user);&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error al actualizar usuario&quot;, &quot;UPDATE&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado al actualizar usuario&quot;, &quot;UPDATE&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void delete(User user) {&#10;        try {&#10;            TransactionUtil.executeInTransaction(em -&gt; {&#10;                try {&#10;                    User managedUser = em.merge(user);&#10;                    em.remove(managedUser);&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error al eliminar usuario&quot;, &quot;DELETE&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado al eliminar usuario&quot;, &quot;DELETE&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public boolean existsById(Long id) {&#10;        try {&#10;            Long count = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;Long&gt; query = em.createQuery(&#10;                        &quot;SELECT COUNT(u.id) FROM User u WHERE u.id = :id&quot;, Long.class);&#10;                    query.setParameter(&quot;id&quot;, id);&#10;                    return query.getSingleResult();&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error verificando existencia de usuario por ID: &quot; + id, &quot;EXISTS&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;            return count &gt; 0;&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado verificando existencia por ID: &quot; + id, &quot;EXISTS&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    // =====================================================================&#10;    // BÚSQUEDAS ÚNICAS User&#10;    // =====================================================================&#10;&#10;    @Override&#10;    public Optional&lt;User&gt; findByEmail(String email) {&#10;        try {&#10;            User user = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#10;                        &quot;SELECT u FROM User u WHERE u.email = :email&quot;, User.class);&#10;                    query.setParameter(&quot;email&quot;, email);&#10;                    return query.getSingleResult();&#10;                } catch (NoResultException e) {&#10;                    return null;&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error consultando usuario por email: &quot; + email, &quot;FIND_BY_EMAIL&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;            return Optional.ofNullable(user);&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado consultando por email: &quot; + email, &quot;FIND_BY_EMAIL&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Optional&lt;User&gt; findByDni(String dni) {&#10;        try {&#10;            User user = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#10;                        &quot;SELECT u FROM User u WHERE u.dni = :dni&quot;, User.class);&#10;                    query.setParameter(&quot;dni&quot;, dni);&#10;                    return query.getSingleResult();&#10;                } catch (NoResultException e) {&#10;                    return null;&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error consultando usuario por DNI: &quot; + dni, &quot;FIND_BY_DNI&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;            return Optional.ofNullable(user);&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado consultando por DNI: &quot; + dni, &quot;FIND_BY_DNI&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    // =====================================================================&#10;    // VALIDACIONES DE EXISTENCIA CON JPA&#10;    // =====================================================================&#10;&#10;    @Override&#10;    public boolean existsByEmail(String email) {&#10;        try {&#10;            Long count = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;Long&gt; query = em.createQuery(&#10;                        &quot;SELECT COUNT(u.id) FROM User u WHERE u.email = :email&quot;, Long.class);&#10;                    query.setParameter(&quot;email&quot;, email);&#10;                    return query.getSingleResult();&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error verificando existencia de email: &quot; + email, &quot;EXISTS_BY_EMAIL&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;            return count &gt; 0;&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado verificando email: &quot; + email, &quot;EXISTS_BY_EMAIL&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public boolean existsByDni(String dni) {&#10;        try {&#10;            Long count = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;Long&gt; query = em.createQuery(&#10;                        &quot;SELECT COUNT(u.id) FROM User u WHERE u.dni = :dni&quot;, Long.class);&#10;                    query.setParameter(&quot;dni&quot;, dni);&#10;                    return query.getSingleResult();&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error verificando existencia de DNI: &quot; + dni, &quot;EXISTS_BY_DNI&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;            return count &gt; 0;&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado verificando DNI: &quot; + dni, &quot;EXISTS_BY_DNI&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    // =====================================================================&#10;    // BÚSQUEDAS MÚLTIPLES CON JPA&#10;    // =====================================================================&#10;&#10;    @Override&#10;    public List&lt;User&gt; findByActiveLoans() {&#10;        try {&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#10;                        &quot;SELECT DISTINCT u FROM User u JOIN u.loans l WHERE l.returnedAt IS NULL&quot;, User.class);&#10;                    return query.getResultList();&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error consultando usuarios con préstamos activos&quot;, &quot;FIND_BY_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado consultando usuarios con préstamos activos&quot;, &quot;FIND_BY_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;User&gt; findByOverdueLoans() {&#10;        try {&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#10;                        &quot;SELECT DISTINCT u FROM User u JOIN u.loans l WHERE l.returnedAt IS NULL AND l.dueDate &lt; :today&quot;, User.class);&#10;                    query.setParameter(&quot;today&quot;, LocalDate.now());&#10;                    return query.getResultList();&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error consultando usuarios con préstamos vencidos&quot;, &quot;FIND_BY_OVERDUE_LOANS&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado consultando usuarios con préstamos vencidos&quot;, &quot;FIND_BY_OVERDUE_LOANS&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    // =====================================================================&#10;    // PAGINACIÓN CON JPA&#10;    // =====================================================================&#10;&#10;    @Override&#10;    public List&lt;User&gt; findPaginated(int page, int size) {&#10;        try {&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#10;                        &quot;SELECT u FROM User u ORDER BY u.lastName, u.firstName&quot;, User.class);&#10;                    query.setFirstResult(page * size);&#10;                    query.setMaxResults(size);&#10;                    return query.getResultList();&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error en consulta paginada&quot;, &quot;FIND_PAGINATED&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado en consulta paginada&quot;, &quot;FIND_PAGINATED&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;User&gt; searchByName(String namePattern, int page, int size) {&#10;        try {&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#10;                        &quot;SELECT u FROM User u WHERE LOWER(CONCAT(u.firstName, ' ', u.lastName)) LIKE LOWER(:pattern) ORDER BY u.lastName, u.firstName&quot;, User.class);&#10;                    query.setParameter(&quot;pattern&quot;, &quot;%&quot; + namePattern + &quot;%&quot;);&#10;                    query.setFirstResult(page * size);&#10;                    query.setMaxResults(size);&#10;                    return query.getResultList();&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error buscando usuarios por nombre: &quot; + namePattern, &quot;SEARCH_BY_NAME&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado buscando por nombre: &quot; + namePattern, &quot;SEARCH_BY_NAME&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Long countByActiveLoans() {&#10;        try {&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;Long&gt; query = em.createQuery(&#10;                        &quot;SELECT COUNT(DISTINCT u.id) FROM User u JOIN u.loans l WHERE l.returnedAt IS NULL&quot;, Long.class);&#10;                    return query.getSingleResult();&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error contando usuarios con préstamos activos&quot;, &quot;COUNT_BY_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado contando usuarios con préstamos activos&quot;, &quot;COUNT_BY_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.libraryManagement.repository.impl;&#13;&#10;&#13;&#10;import com.libraryManagement.config.db.TransactionUtil;&#13;&#10;import com.libraryManagement.exception.repository.RepositoryException;&#13;&#10;import com.libraryManagement.model.User;&#13;&#10;import com.libraryManagement.repository.interfaces.UserRepository;&#13;&#10;import jakarta.persistence.NoResultException;&#13;&#10;import jakarta.persistence.TypedQuery;&#13;&#10;&#13;&#10;import java.time.LocalDate;&#13;&#10;import java.util.List;&#13;&#10;import java.util.Optional;&#13;&#10;&#13;&#10;/**&#13;&#10; * IMPLEMENTACIÓN PROFESIONAL DE UserRepository&#13;&#10; * USANDO JPA + TransactionUtil OPTIMIZADO&#13;&#10; *&#13;&#10; * Orden de métodos:&#13;&#10; * 1. Métodos de GenericRepository (CRUD básico)&#13;&#10; * 2. Métodos específicos de UserRepository (en orden de interface)&#13;&#10; */&#13;&#10;public class UserRepositoryImpl implements UserRepository {&#13;&#10;&#13;&#10;    // =====================================================================&#13;&#10;    // MÉTODOS DE GENERIC REPOSITORY - CON JPA + TransactionUtil OPTIMIZADO&#13;&#10;    // =====================================================================&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public User save(User user) {&#13;&#10;        try {&#13;&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    return em.merge(user);&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error al guardar usuario&quot;, &quot;SAVE&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado al guardar usuario&quot;, &quot;SAVE&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public Optional&lt;User&gt; findById(Long id) {&#13;&#10;        try {&#13;&#10;            User user = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    return em.find(User.class, id);&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error consultando usuario por ID: &quot; + id, &quot;FIND&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;            return Optional.ofNullable(user);&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado consultando usuario por ID: &quot; + id, &quot;FIND&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public List&lt;User&gt; findAll() {&#13;&#10;        try {&#13;&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT u FROM User u ORDER BY u.lastName, u.firstName&quot;, User.class);&#13;&#10;                    return query.getResultList();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error consultando todos los usuarios&quot;, &quot;FIND_ALL&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado consultando todos los usuarios&quot;, &quot;FIND_ALL&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public void update(User user) {&#13;&#10;        try {&#13;&#10;            TransactionUtil.executeInTransaction(em -&gt; {&#13;&#10;                try {&#13;&#10;                    em.merge(user);&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error al actualizar usuario&quot;, &quot;UPDATE&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado al actualizar usuario&quot;, &quot;UPDATE&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public void delete(User user) {&#13;&#10;        try {&#13;&#10;            TransactionUtil.executeInTransaction(em -&gt; {&#13;&#10;                try {&#13;&#10;                    User managedUser = em.merge(user);&#13;&#10;                    em.remove(managedUser);&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error al eliminar usuario&quot;, &quot;DELETE&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado al eliminar usuario&quot;, &quot;DELETE&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public boolean existsById(Long id) {&#13;&#10;        try {&#13;&#10;            Long count = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;Long&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT COUNT(u.id) FROM User u WHERE u.id = :id&quot;, Long.class);&#13;&#10;                    query.setParameter(&quot;id&quot;, id);&#13;&#10;                    return query.getSingleResult();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error verificando existencia de usuario por ID: &quot; + id, &quot;EXISTS&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;            return count &gt; 0;&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado verificando existencia por ID: &quot; + id, &quot;EXISTS&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // =====================================================================&#13;&#10;    // BÚSQUEDAS ÚNICAS User&#13;&#10;    // =====================================================================&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public Optional&lt;User&gt; findByEmail(String email) {&#13;&#10;        try {&#13;&#10;            User user = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT u FROM User u WHERE u.email = :email&quot;, User.class);&#13;&#10;                    query.setParameter(&quot;email&quot;, email);&#13;&#10;                    return query.getSingleResult();&#13;&#10;                } catch (NoResultException e) {&#13;&#10;                    return null;&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error consultando usuario por email: &quot; + email, &quot;FIND_BY_EMAIL&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;            return Optional.ofNullable(user);&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado consultando por email: &quot; + email, &quot;FIND_BY_EMAIL&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public Optional&lt;User&gt; findByDni(String dni) {&#13;&#10;        try {&#13;&#10;            User user = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT u FROM User u WHERE u.dni = :dni&quot;, User.class);&#13;&#10;                    query.setParameter(&quot;dni&quot;, dni);&#13;&#10;                    return query.getSingleResult();&#13;&#10;                } catch (NoResultException e) {&#13;&#10;                    return null;&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error consultando usuario por DNI: &quot; + dni, &quot;FIND_BY_DNI&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;            return Optional.ofNullable(user);&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado consultando por DNI: &quot; + dni, &quot;FIND_BY_DNI&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // =====================================================================&#13;&#10;    // VALIDACIONES DE EXISTENCIA CON JPA&#13;&#10;    // =====================================================================&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public boolean existsByEmail(String email) {&#13;&#10;        try {&#13;&#10;            Long count = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;Long&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT COUNT(u.id) FROM User u WHERE u.email = :email&quot;, Long.class);&#13;&#10;                    query.setParameter(&quot;email&quot;, email);&#13;&#10;                    return query.getSingleResult();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error verificando existencia de email: &quot; + email, &quot;EXISTS_BY_EMAIL&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;            return count &gt; 0;&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado verificando email: &quot; + email, &quot;EXISTS_BY_EMAIL&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public boolean existsByDni(String dni) {&#13;&#10;        try {&#13;&#10;            Long count = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;Long&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT COUNT(u.id) FROM User u WHERE u.dni = :dni&quot;, Long.class);&#13;&#10;                    query.setParameter(&quot;dni&quot;, dni);&#13;&#10;                    return query.getSingleResult();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error verificando existencia de DNI: &quot; + dni, &quot;EXISTS_BY_DNI&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;            return count &gt; 0;&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado verificando DNI: &quot; + dni, &quot;EXISTS_BY_DNI&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // =====================================================================&#13;&#10;    // BÚSQUEDAS MÚLTIPLES CON JPA&#13;&#10;    // =====================================================================&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public List&lt;User&gt; findByActiveLoans() {&#13;&#10;        try {&#13;&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT DISTINCT u FROM User u JOIN u.loans l WHERE l.returnedAt IS NULL&quot;, User.class);&#13;&#10;                    return query.getResultList();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error consultando usuarios con préstamos activos&quot;, &quot;FIND_BY_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado consultando usuarios con préstamos activos&quot;, &quot;FIND_BY_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public List&lt;User&gt; findByOverdueLoans() {&#13;&#10;        try {&#13;&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT DISTINCT u FROM User u JOIN u.loans l WHERE l.returnedAt IS NULL AND l.dueDate &lt; :today&quot;, User.class);&#13;&#10;                    query.setParameter(&quot;today&quot;, LocalDate.now());&#13;&#10;                    return query.getResultList();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error consultando usuarios con préstamos vencidos&quot;, &quot;FIND_BY_OVERDUE_LOANS&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado consultando usuarios con préstamos vencidos&quot;, &quot;FIND_BY_OVERDUE_LOANS&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // =====================================================================&#13;&#10;    // PAGINACIÓN CON JPA&#13;&#10;    // =====================================================================&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public List&lt;User&gt; findPaginated(int page, int size) {&#13;&#10;        try {&#13;&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT u FROM User u ORDER BY u.lastName, u.firstName&quot;, User.class);&#13;&#10;                    query.setFirstResult(page * size);&#13;&#10;                    query.setMaxResults(size);&#13;&#10;                    return query.getResultList();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error en consulta paginada&quot;, &quot;FIND_PAGINATED&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado en consulta paginada&quot;, &quot;FIND_PAGINATED&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public List&lt;User&gt; searchByName(String namePattern, int page, int size) {&#13;&#10;        try {&#13;&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT u FROM User u WHERE LOWER(CONCAT(u.firstName, ' ', u.lastName)) LIKE LOWER(:pattern) ORDER BY u.lastName, u.firstName&quot;, User.class);&#13;&#10;                    query.setParameter(&quot;pattern&quot;, &quot;%&quot; + namePattern + &quot;%&quot;);&#13;&#10;                    query.setFirstResult(page * size);&#13;&#10;                    query.setMaxResults(size);&#13;&#10;                    return query.getResultList();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error buscando usuarios por nombre: &quot; + namePattern, &quot;SEARCH_BY_NAME&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado buscando por nombre: &quot; + namePattern, &quot;SEARCH_BY_NAME&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public Long countByActiveLoans() {&#13;&#10;        try {&#13;&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;Long&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT COUNT(DISTINCT u.id) FROM User u JOIN u.loans l WHERE l.returnedAt IS NULL&quot;, Long.class);&#13;&#10;                    return query.getSingleResult();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error contando usuarios con préstamos activos&quot;, &quot;COUNT_BY_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado contando usuarios con préstamos activos&quot;, &quot;COUNT_BY_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // =====================================================================&#13;&#10;    // VALIDACIONES DE NEGOCIO - Sin cargar colecciones completas&#13;&#10;    // =====================================================================&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public boolean hasActiveLoans(Long userId) {&#13;&#10;        try {&#13;&#10;            Long count = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;Long&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT COUNT(l.id) FROM Loan l WHERE l.user.id = :userId AND l.returnedAt IS NULL&quot;, &#13;&#10;                        Long.class);&#13;&#10;                    query.setParameter(&quot;userId&quot;, userId);&#13;&#10;                    return query.getSingleResult();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error verificando préstamos activos del usuario: &quot; + userId, &quot;HAS_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;            return count &gt; 0;&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado verificando préstamos activos: &quot; + userId, &quot;HAS_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public Long countActiveLoansByUserId(Long userId) {&#13;&#10;        try {&#13;&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;Long&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT COUNT(l.id) FROM Loan l WHERE l.user.id = :userId AND l.returnedAt IS NULL&quot;, &#13;&#10;                        Long.class);&#13;&#10;                    query.setParameter(&quot;userId&quot;, userId);&#13;&#10;                    return query.getSingleResult();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error contando préstamos activos del usuario: &quot; + userId, &quot;COUNT_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado contando préstamos activos: &quot; + userId, &quot;COUNT_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/repository/interfaces/UserRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/repository/interfaces/UserRepository.java" />
              <option name="originalContent" value="package com.libraryManagement.repository.interfaces;&#10;&#10;import com.libraryManagement.model.User;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public interface UserRepository extends GenericRepository&lt;User, Long&gt; {&#10;&#10;    // =====================================================================&#10;    // BÚSQUEDAS ÚNICAS - Usan Optional porque pueden no existir&#10;    // =====================================================================&#10;&#10;    Optional&lt;User&gt; findByEmail(String email);&#10;    Optional&lt;User&gt; findByDni(String dni);&#10;&#10;    // =====================================================================&#10;    // VALIDACIONES DE EXISTENCIA - Para validaciones rápidas&#10;    // =====================================================================&#10;&#10;    boolean existsByEmail(String email);&#10;    boolean existsByDni(String dni);&#10;&#10;    // =====================================================================&#10;    // BÚSQUEDAS MÚLTIPLES&#10;    // =====================================================================&#10;&#10;    List&lt;User&gt; findByActiveLoans();&#10;    List&lt;User&gt; findByOverdueLoans();&#10;&#10;    // =====================================================================&#10;    // PAGINACIÓN - Para todas las búsquedas masivas&#10;    // =====================================================================&#10;&#10;    List&lt;User&gt; findPaginated(int page, int size);&#10;    List&lt;User&gt; searchByName(String namePattern, int page, int size);&#10;&#10;&#10;    Long countByActiveLoans();&#10;&#10;}" />
              <option name="updatedContent" value="package com.libraryManagement.repository.interfaces;&#10;&#10;import com.libraryManagement.model.User;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public interface UserRepository extends GenericRepository&lt;User, Long&gt; {&#10;&#10;    // =====================================================================&#10;    // BÚSQUEDAS ÚNICAS - Usan Optional porque pueden no existir&#10;    // =====================================================================&#10;&#10;    Optional&lt;User&gt; findByEmail(String email);&#10;    Optional&lt;User&gt; findByDni(String dni);&#10;&#10;    // =====================================================================&#10;    // VALIDACIONES DE EXISTENCIA - Para validaciones rápidas&#10;    // =====================================================================&#10;&#10;    boolean existsByEmail(String email);&#10;    boolean existsByDni(String dni);&#10;&#10;    // =====================================================================&#10;    // BÚSQUEDAS MÚLTIPLES&#10;    // =====================================================================&#10;&#10;    List&lt;User&gt; findByActiveLoans();&#10;    List&lt;User&gt; findByOverdueLoans();&#10;&#10;    // =====================================================================&#10;    // PAGINACIÓN - Para todas las búsquedas masivas&#10;    // =====================================================================&#10;&#10;    List&lt;User&gt; findPaginated(int page, int size);&#10;    List&lt;User&gt; searchByName(String namePattern, int page, int size);&#10;&#10;&#10;    Long countByActiveLoans();&#10;&#10;    // =====================================================================&#10;    // VALIDACIONES DE NEGOCIO - Sin cargar colecciones completas&#10;    // =====================================================================&#10;&#10;    /**&#10;     * Cuenta préstamos activos de un usuario sin cargar la colección&#10;     * PREVIENE: LazyInitializationException&#10;     * USO: Validaciones antes de eliminar usuario&#10;     */&#10;    boolean hasActiveLoans(Long userId);&#10;&#10;    /**&#10;     * Cuenta total de préstamos activos de un usuario&#10;     * ALTERNATIVA: Si necesitas el número exacto&#10;     */&#10;    Long countActiveLoansByUserId(Long userId);&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/util/UserUtils.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/util/UserUtils.java" />
              <option name="updatedContent" value="package com.libraryManagement.util;&#10;&#10;import java.time.LocalDate;&#10;import java.time.Period;&#10;&#10;/**&#10; * UTILIDADES PARA USER - Solo cálculos puros sin lógica de negocio&#10; *&#10; * Contiene métodos estáticos para cálculos que no dependen del estado&#10; * de la aplicación ni requieren acceso a base de datos&#10; */&#10;public class UserUtils {&#10;&#10;    /**&#10;     * Calcula la edad basada en fecha de nacimiento&#10;     *&#10;     * @param dateOfBirth fecha de nacimiento&#10;     * @return edad en años, null si dateOfBirth es null, 0 si es fecha futura&#10;     */&#10;    public static Integer calculateAge(LocalDate dateOfBirth) {&#10;        if (dateOfBirth == null) {&#10;            return null;&#10;        }&#10;&#10;        LocalDate now = LocalDate.now();&#10;        if (dateOfBirth.isAfter(now)) {&#10;            return 0; // Fecha futura = 0 años&#10;        }&#10;&#10;        return Period.between(dateOfBirth, now).getYears();&#10;    }&#10;&#10;    /**&#10;     * Extrae el nombre de ciudad de una dirección&#10;     *&#10;     * @param address dirección del usuario&#10;     * @return nombre de la ciudad o null si address es null&#10;     */&#10;    public static String extractCityName(com.libraryManagement.model.Address address) {&#10;        if (address == null) {&#10;            return null;&#10;        }&#10;        return address.getCity();&#10;    }&#10;&#10;    /**&#10;     * Calcula estado de membresía basado en el estado del usuario&#10;     *&#10;     * REGLAS DE NEGOCIO:&#10;     * - SUSPENDED: Tiene préstamos vencidos&#10;     * - LIMITED: 3+ préstamos activos&#10;     * - ACTIVE: Estado normal&#10;     *&#10;     * @param user usuario a evaluar&#10;     * @return estado de membresía&#10;     */&#10;    public static String calculateMembershipStatus(com.libraryManagement.model.User user) {&#10;        if (user == null || user.getLoans() == null) {&#10;            return &quot;ACTIVE&quot;;&#10;        }&#10;&#10;        // Contar préstamos activos&#10;        long activeLoans = user.getLoans().stream()&#10;            .filter(loan -&gt; loan.getReturnedAt() == null)&#10;            .count();&#10;&#10;        // Verificar préstamos vencidos&#10;        boolean hasOverdueLoans = user.getLoans().stream()&#10;            .filter(loan -&gt; loan.getReturnedAt() == null)&#10;            .anyMatch(loan -&gt; loan.getDueDate().isBefore(LocalDate.now()));&#10;&#10;        if (hasOverdueLoans) {&#10;            return &quot;SUSPENDED&quot;;&#10;        } else if (activeLoans &gt;= 3) {&#10;            return &quot;LIMITED&quot;;&#10;        } else {&#10;            return &quot;ACTIVE&quot;;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Formatea nombre completo del usuario&#10;     *&#10;     * @param firstName nombre&#10;     * @param lastName apellido&#10;     * @return nombre completo formateado&#10;     */&#10;    public static String formatFullName(String firstName, String lastName) {&#10;        if (firstName == null &amp;&amp; lastName == null) {&#10;            return &quot;Nombre no disponible&quot;;&#10;        }&#10;        &#10;        String first = firstName != null ? firstName.trim() : &quot;&quot;;&#10;        String last = lastName != null ? lastName.trim() : &quot;&quot;;&#10;        &#10;        if (first.isEmpty() &amp;&amp; last.isEmpty()) {&#10;            return &quot;Nombre no disponible&quot;;&#10;        }&#10;        &#10;        return (first + &quot; &quot; + last).trim();&#10;    }&#10;&#10;    /**&#10;     * Valida formato de DNI argentino&#10;     *&#10;     * @param dni documento a validar&#10;     * @return true si es válido&#10;     */&#10;    public static boolean isValidArgentinianDNI(String dni) {&#10;        if (dni == null || dni.trim().isEmpty()) {&#10;            return false;&#10;        }&#10;        &#10;        // Remover espacios y puntos&#10;        String cleanDNI = dni.replaceAll(&quot;[\\s.]&quot;, &quot;&quot;);&#10;        &#10;        // Debe tener entre 7 y 8 dígitos&#10;        return cleanDNI.matches(&quot;\\d{7,8}&quot;);&#10;    }&#10;&#10;    /**&#10;     * Valida formato de email&#10;     *&#10;     * @param email email a validar&#10;     * @return true si es válido&#10;     */&#10;    public static boolean isValidEmail(String email) {&#10;        if (email == null || email.trim().isEmpty()) {&#10;            return false;&#10;        }&#10;        &#10;        // Regex básico para email&#10;        String emailRegex = &quot;^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$&quot;;&#10;        return email.matches(emailRegex);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/util/validation/DTOValidator.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/util/validation/DTOValidator.java" />
              <option name="originalContent" value="package com.libraryManagement.util.validation;&#10;&#10;import jakarta.validation.ConstraintViolation;&#10;import jakarta.validation.Validation;&#10;import jakarta.validation.Validator;&#10;import jakarta.validation.ValidatorFactory;&#10;import com.libraryManagement.util.Logger;&#10;&#10;import java.util.Set;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * VALIDADOR MANUAL PARA DTOs&#10; *&#10; * Ejecuta las validaciones de @NotNull, @NotBlank, @Email, etc.&#10; * que están en los DTOs pero no se ejecutan automáticamente con Jackson.&#10; */&#10;public class DTOValidator {&#10;&#10;    private static final Validator validator;&#10;&#10;    static {&#10;        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();&#10;        validator = factory.getValidator();&#10;        Logger.info(&quot;DTOValidator&quot;, &quot;Inicializado correctamente&quot;);&#10;    }&#10;    /**&#10;     * Valida un DTO y lanza excepción si hay errores&#10;     */&#10;    public static &lt;T&gt; void validate(T dto) {&#10;        if (dto == null) {&#10;            Logger.warn(&quot;DTOValidator&quot;, &quot;Intento de validar DTO nulo&quot;);&#10;            throw new IllegalArgumentException(&quot;DTO no puede ser nulo&quot;);&#10;        }&#10;&#10;        Set&lt;ConstraintViolation&lt;T&gt;&gt; violations = validator.validate(dto);&#10;&#10;        if (!violations.isEmpty()) {&#10;            String errorMessage = violations.stream()&#10;                    .map(ConstraintViolation::getMessage)&#10;                    .collect(Collectors.joining(&quot;, &quot;));&#10;&#10;            Logger.warn(&quot;Validación fallida para &quot; + dto.getClass().getSimpleName() +&#10;                &quot;: &quot; + violations.size() + &quot; errores encontrados - &quot; + errorMessage);&#10;&#10;            violations.forEach(violation -&gt;&#10;                Logger.debug(&quot;   Campo '&quot; + violation.getPropertyPath() + &quot;': &quot; +&#10;                    violation.getMessage() + &quot; (valor: '&quot; + violation.getInvalidValue() + &quot;')&quot;)&#10;            );&#10;&#10;            throw new IllegalArgumentException(&quot;Datos inválidos: &quot; + errorMessage);&#10;        }&#10;&#10;        Logger.debug(&quot;Validación exitosa para &quot; + dto.getClass().getSimpleName());&#10;    }&#10;    /**&#10;     * Valida un DTO y retorna lista de errores sin lanzar excepción&#10;     */&#10;    public static &lt;T&gt; Set&lt;String&gt; getValidationErrors(T dto) {&#10;        if (dto == null) {&#10;            Logger.warn(&quot;DTOValidator&quot;, &quot;Intento de obtener errores de DTO nulo&quot;);&#10;            return Set.of(&quot;DTO no puede ser nulo&quot;);&#10;        }&#10;&#10;        Set&lt;ConstraintViolation&lt;T&gt;&gt; violations = validator.validate(dto);&#10;&#10;        if (!violations.isEmpty()) {&#10;            Logger.debug(&quot;Obteniendo &quot; + violations.size() + &quot; errores de validación para &quot; +&#10;                dto.getClass().getSimpleName());&#10;        }&#10;&#10;        return violations.stream()&#10;                .map(ConstraintViolation::getMessage)&#10;                .collect(Collectors.toSet());&#10;    }&#10;&#10;    /**&#10;     * Verifica si un DTO es válido&#10;     */&#10;    public static &lt;T&gt; boolean isValid(T dto) {&#10;        if (dto == null) {&#10;            Logger.debug(&quot;DTO nulo considerado inválido&quot;);&#10;            return false;&#10;        }&#10;&#10;        boolean valid = validator.validate(dto).isEmpty();&#10;&#10;        Logger.debug(&quot;Validación rápida para &quot; + dto.getClass().getSimpleName() + &quot;: &quot; +&#10;            (valid ? &quot;VÁLIDO&quot; : &quot;INVÁLIDO&quot;));&#10;&#10;        return valid;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.libraryManagement.util.validation;&#13;&#10;&#13;&#10;import jakarta.validation.ConstraintViolation;&#13;&#10;import jakarta.validation.Validation;&#13;&#10;import jakarta.validation.Validator;&#13;&#10;import jakarta.validation.ValidatorFactory;&#13;&#10;import java.util.Set;&#13;&#10;import java.util.stream.Collectors;&#13;&#10;&#13;&#10;/**&#13;&#10; * VALIDADOR GENÉRICO PARA DTOs&#13;&#10; * &#13;&#10; * Contiene validaciones TRANSVERSALES que se usan en toda la aplicación&#13;&#10; * NO contiene lógica de negocio específica de entidades&#13;&#10; */&#13;&#10;public class DTOValidator {&#13;&#10;&#13;&#10;    private static final ValidatorFactory factory = Validation.buildDefaultValidatorFactory();&#13;&#10;    private static final Validator validator = factory.getValidator();&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Valida un DTO usando anotaciones Bean Validation&#13;&#10;     */&#13;&#10;    public static &lt;T&gt; void validate(T dto) {&#13;&#10;        Set&lt;ConstraintViolation&lt;T&gt;&gt; violations = validator.validate(dto);&#13;&#10;&#13;&#10;        if (!violations.isEmpty()) {&#13;&#10;            String errorMessage = violations.stream()&#13;&#10;                    .map(ConstraintViolation::getMessage)&#13;&#10;                    .collect(Collectors.joining(&quot;, &quot;));&#13;&#10;            &#13;&#10;            throw new IllegalArgumentException(&quot;Datos inválidos: &quot; + errorMessage);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Valida un DTO y retorna lista de errores sin lanzar excepción&#13;&#10;     */&#13;&#10;    public static &lt;T&gt; Set&lt;String&gt; getValidationErrors(T dto) {&#13;&#10;        Set&lt;ConstraintViolation&lt;T&gt;&gt; violations = validator.validate(dto);&#13;&#10;&#13;&#10;        return violations.stream()&#13;&#10;                .map(ConstraintViolation::getMessage)&#13;&#10;                .collect(Collectors.toSet());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Verifica si un DTO es válido&#13;&#10;     */&#13;&#10;    public static &lt;T&gt; boolean isValid(T dto) {&#13;&#10;        return validator.validate(dto).isEmpty();&#13;&#10;    }&#13;&#10;&#13;&#10;    // =====================================================================&#13;&#10;    // VALIDACIONES TRANSVERSALES - Usadas en toda la aplicación&#13;&#10;    // =====================================================================&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Valida formato de DNI argentino (TRANSVERSAL)&#13;&#10;     */&#13;&#10;    public static boolean isValidArgentinianDNI(String dni) {&#13;&#10;        if (dni == null || dni.trim().isEmpty()) {&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;        &#13;&#10;        String cleanDNI = dni.replaceAll(&quot;[\\s.]&quot;, &quot;&quot;);&#13;&#10;        return cleanDNI.matches(&quot;\\d{7,8}&quot;);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Valida formato de email (TRANSVERSAL)&#13;&#10;     */&#13;&#10;    public static boolean isValidEmail(String email) {&#13;&#10;        if (email == null || email.trim().isEmpty()) {&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;        &#13;&#10;        String emailRegex = &quot;^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$&quot;;&#13;&#10;        return email.matches(emailRegex);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Valida que un string no esté vacío (TRANSVERSAL)&#13;&#10;     */&#13;&#10;    public static boolean isNotBlank(String text) {&#13;&#10;        return text != null &amp;&amp; !text.trim().isEmpty();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Valida rango numérico (TRANSVERSAL)&#13;&#10;     */&#13;&#10;    public static boolean isInRange(Number value, Number min, Number max) {&#13;&#10;        if (value == null || min == null || max == null) {&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;        &#13;&#10;        double val = value.doubleValue();&#13;&#10;        double minVal = min.doubleValue();&#13;&#10;        double maxVal = max.doubleValue();&#13;&#10;        &#13;&#10;        return val &gt;= minVal &amp;&amp; val &lt;= maxVal;&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/META-INF/persistence.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/META-INF/persistence.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;persistence xmlns=&quot;https://jakarta.ee/xml/ns/persistence&quot; version=&quot;3.0&quot;&gt;&#10;    &lt;persistence-unit name=&quot;libraryPU&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt;&#10;        &lt;!--  Clases JPA (solo ejemplos; agregá todas tus entidades reales) --&gt;&#10;        &lt;class&gt;com.libraryManagement.model.User&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.Book&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.Copy&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.Loan&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.LoanLine&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.Publication&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.Magazine&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.Author&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.Publisher&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.Genre&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.Address&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.Base&lt;/class&gt;&#10;&#10;        &lt;!-- ⚙️ Configuración JDBC para MySQL --&gt;&#10;        &lt;properties&gt;&#10;            &lt;!-- Conexión --&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.url&quot; value=&quot;jdbc:mysql://localhost:3306/librarydb?useSSL=false&amp;amp;serverTimezone=UTC&quot;/&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.user&quot; value=&quot;root&quot;/&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.password&quot; value=&quot;1234&quot;/&gt;&#10;&#10;            &lt;!-- Proveedor JPA --&gt;&#10;            &lt;property name=&quot;jakarta.persistence.provider&quot; value=&quot;org.hibernate.jpa.HibernatePersistenceProvider&quot;/&gt;&#10;&#10;            &lt;!-- Dialecto de MySQL --&gt;&#10;            &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.MySQL8Dialect&quot;/&gt;&#10;&#10;            &lt;!-- ️ Mostrar SQL en consola --&gt;&#10;            &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt;&#10;&#10;            &lt;!--  Opciones de generación de esquema --&gt;&#10;            &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot;/&gt;&#10;            &lt;!-- Para desarrollo puede ser “create-drop” o “create”, pero “update” evita borrar datos en cada ejecución --&gt;&#10;        &lt;/properties&gt;&#10;    &lt;/persistence-unit&gt;&#10;&lt;/persistence&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#10;&lt;persistence xmlns=&quot;https://jakarta.ee/xml/ns/persistence&quot; version=&quot;3.0&quot;&gt;&#10;    &lt;persistence-unit name=&quot;libraryPU&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt;&#10;        &lt;!--  Clases JPA (solo ejemplos; agregá todas tus entidades reales) --&gt;&#10;        &lt;class&gt;com.libraryManagement.model.User&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.Book&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.Copy&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.Loan&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.LoanLine&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.Publication&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.Magazine&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.Author&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.Publisher&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.Genre&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.Address&lt;/class&gt;&#10;        &lt;class&gt;com.libraryManagement.model.Base&lt;/class&gt;&#10;&#10;        &lt;!-- ⚙️ Configuración JDBC para MySQL --&gt;&#10;        &lt;properties&gt;&#10;            &lt;!--  CONEXIÓN CON CREACIÓN AUTOMÁTICA DE BD --&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt;&#10;            &lt;!-- ✨ URL MODIFICADA: allowPublicKeyRetrieval + createDatabaseIfNotExist --&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.url&quot; &#10;                value=&quot;jdbc:mysql://localhost:3306/librarydb?useSSL=false&amp;amp;serverTimezone=UTC&amp;amp;allowPublicKeyRetrieval=true&amp;amp;createDatabaseIfNotExist=true&quot;/&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.user&quot; value=&quot;root&quot;/&gt;&#10;            &lt;property name=&quot;jakarta.persistence.jdbc.password&quot; value=&quot;1234&quot;/&gt;&#10;&#10;            &lt;!--  PROVEEDOR Y DIALECTO --&gt;&#10;            &lt;property name=&quot;jakarta.persistence.provider&quot; value=&quot;org.hibernate.jpa.HibernatePersistenceProvider&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.dialect&quot; value=&quot;org.hibernate.dialect.MySQLDialect&quot;/&gt;&#10;&#10;            &lt;!--  DDL AUTOMÁTICO - CREA TABLAS SI NO EXISTEN --&gt;&#10;            &lt;property name=&quot;hibernate.hbm2ddl.auto&quot; value=&quot;update&quot;/&gt;&#10;            &#10;            &lt;!--  LOGGING Y DEBUG --&gt;&#10;            &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.format_sql&quot; value=&quot;true&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.use_sql_comments&quot; value=&quot;true&quot;/&gt;&#10;            &#10;            &lt;!-- ⚡ OPTIMIZACIONES --&gt;&#10;            &lt;property name=&quot;hibernate.connection.pool_size&quot; value=&quot;10&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.current_session_context_class&quot; value=&quot;thread&quot;/&gt;&#10;            &lt;property name=&quot;hibernate.cache.use_second_level_cache&quot; value=&quot;false&quot;/&gt;&#10;        &lt;/properties&gt;&#10;    &lt;/persistence-unit&gt;&#10;&lt;/persistence&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>