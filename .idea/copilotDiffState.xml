<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/Main.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/Main.java" />
              <option name="updatedContent" value="package com.libraryManagement;&#10;&#10;import com.libraryManagement.config.ApplicationBootstrap;&#10;&#10;/**&#10; *  PUNTO DE ENTRADA PRINCIPAL DE LA APLICACIÓN&#10; * &#10; * Clase Main que inicia todo el sistema Library Management&#10; */&#10;public class Main {&#10;&#10;    public static void main(String[] args) {&#10;        System.out.println(&quot;=&quot;.repeat(60));&#10;        System.out.println(&quot; LIBRARY MANAGEMENT SYSTEM&quot;);&#10;        System.out.println(&quot;=&quot;.repeat(60));&#10;&#10;        // Crear e iniciar el bootstrap de la aplicación&#10;        ApplicationBootstrap bootstrap = new ApplicationBootstrap();&#10;        &#10;        try {&#10;            // Iniciar todo el sistema&#10;            bootstrap.start();&#10;            &#10;            // Mantener la aplicación corriendo&#10;            System.out.println(&quot;\n Presiona Ctrl+C para detener el servidor&quot;);&#10;            &#10;            // Mantener el hilo principal vivo&#10;            Thread.currentThread().join();&#10;            &#10;        } catch (Exception e) {&#10;            System.err.println(&quot; Error fatal en la aplicación: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;            System.exit(1);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/db/JpaConfig.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/db/JpaConfig.java" />
              <option name="originalContent" value="package com.libraryManagement.config.db;&#10;&#10;import jakarta.persistence.EntityManagerFactory;&#10;import jakarta.persistence.Persistence;&#10;&#10;/**&#10; *  Clase de configuración que inicializa y expone el EntityManagerFactory&#10; *  * de forma centralizada. Se utiliza para gestionar la conexión JPA con la base de datos.&#10; */&#10;public class JpaConfig {&#10;&#10;    // Instancia única y global de EntityManagerFactory&#10;    private static final EntityManagerFactory emf;&#10;&#10;    static {&#10;        try {&#10;            // Crea el EntityManagerFactory a partir del archivo persistence.xml&#10;            // El nombre 'libraryPU' debe coincidir con el persistence-unit definido&#10;            emf = Persistence.createEntityManagerFactory(&quot;libraryPU&quot;);&#10;        } catch (Exception e) {&#10;            throw new RuntimeException(&quot;❌ Error al inicializar EntityManagerFactory&quot;, e);&#10;        }&#10;    }&#10;&#10;   //Retorna la instancia de EntityManagerFactory&#10;    public static EntityManagerFactory getEntityManagerFactory() {&#10;        return emf;&#10;    }&#10;    //Cierra el EntityManagerFactory al finalizar la aplicación&#10;    public static void shutdown() {&#10;        if (emf.isOpen()) emf.close();&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.libraryManagement.config.db;&#10;&#10;import com.libraryManagement.util.Logger; // ← AGREGADO: Logger profesional&#10;import jakarta.persistence.EntityManagerFactory;&#10;import jakarta.persistence.Persistence;&#10;&#10;/**&#10; * Clase de configuración que inicializa y expone el EntityManagerFactory&#10; * de forma centralizada. Se utiliza para gestionar la conexión JPA con la base de datos.&#10; */&#10;public class JpaConfig {&#10;&#10;    // Instancia única y global de EntityManagerFactory&#10;    private static final EntityManagerFactory emf;&#10;&#10;    static {&#10;        try {&#10;            Logger.debug(&quot;JpaConfig&quot;, &quot;Inicializando EntityManagerFactory...&quot;);&#10;            // Crea el EntityManagerFactory a partir del archivo persistence.xml&#10;            // El nombre 'libraryPU' debe coincidir con el persistence-unit definido&#10;            emf = Persistence.createEntityManagerFactory(&quot;libraryPU&quot;);&#10;            Logger.success(&quot;JpaConfig&quot;, &quot;EntityManagerFactory inicializado correctamente&quot;);&#10;        } catch (Exception e) {&#10;            Logger.error(&quot;JpaConfig&quot;, &quot;Error al inicializar EntityManagerFactory&quot;, e);&#10;            throw new RuntimeException(&quot;❌ Error al inicializar EntityManagerFactory&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Retorna la instancia de EntityManagerFactory&#10;     */&#10;    public static EntityManagerFactory getEntityManagerFactory() {&#10;        return emf;&#10;    }&#10;&#10;    /**&#10;     * Cierra el EntityManagerFactory al finalizar la aplicación&#10;     */&#10;    public static void shutdown() {&#10;        if (emf != null &amp;&amp; emf.isOpen()) {&#10;            Logger.info(&quot;JpaConfig&quot;, &quot;Cerrando EntityManagerFactory...&quot;);&#10;            emf.close();&#10;            Logger.info(&quot;JpaConfig&quot;, &quot;EntityManagerFactory cerrado&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/db/TransactionUtil.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/db/TransactionUtil.java" />
              <option name="originalContent" value="package com.libraryManagement.config.db;&#10;&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityTransaction;&#10;&#10;import java.util.function.Consumer;&#10;import java.util.function.Function;&#10;&#10;/**&#10; * Utilidad para manejar transacciones de forma sencilla.&#10; * Permite ejecutar acciones dentro de una transacción&#10; * y manejar errores de forma centralizada.&#10; */&#10;public class TransactionUtil {&#10;    /**&#10;     * Ejecuta una acción con EntityManager dentro de una transacción.&#10;     * Se recomienda para operaciones como persistencia, actualizaciones o eliminación.&#10;     */&#10;    public static void executeInTransaction(Consumer&lt;EntityManager&gt; action){&#10;        EntityManager em = PersistenceManager.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try{&#10;            tx.begin();// Inicia la transacción&#10;            action.accept(em);// Ejecuta la acción principal&#10;            tx.commit(); // Confirma los cambios&#10;        }catch (Exception e){&#10;            if(tx.isActive()) tx.rollback();// Revierte en caso de error&#10;            throw  new RuntimeException(&quot; -- Transacción fallida&quot;, e);&#10;        }finally {&#10;            if(em.isOpen()) em.close();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Ejecuta una función con EntityManager dentro de una transacción y retorna un resultado.&#10;     */&#10;    public static &lt;T&gt; T executeInTransactionWithResult(Function&lt;EntityManager, T&gt; function) {&#10;        EntityManager em = PersistenceManager.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try {&#10;            tx.begin(); // Inicia la transacción&#10;            T result = function.apply(em); // Ejecuta la función y obtiene el resultado&#10;            tx.commit(); // Confirma los cambios&#10;            return result; // Retorna el resultado&#10;        } catch (Exception e) {&#10;            if (tx.isActive()) tx.rollback(); // Revierte en caso de error&#10;            throw new RuntimeException(&quot; -- Transacción fallida&quot;, e);&#10;        } finally {&#10;            if (em.isOpen()) em.close();&#10;        }&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.libraryManagement.config.db;&#10;&#10;import com.libraryManagement.util.Logger; // ← AGREGADO: Logger profesional&#10;import jakarta.persistence.EntityManager;&#10;import jakarta.persistence.EntityTransaction;&#10;&#10;import java.util.function.Consumer;&#10;import java.util.function.Function;&#10;&#10;/**&#10; * Utilidad para manejar transacciones de forma sencilla.&#10; * Permite ejecutar acciones dentro de una transacción&#10; * y manejar errores de forma centralizada.&#10; */&#10;public class TransactionUtil {&#10;    /**&#10;     * Ejecuta una acción con EntityManager dentro de una transacción.&#10;     * Se recomienda para operaciones como persistencia, actualizaciones o eliminación.&#10;     */&#10;    public static void executeInTransaction(Consumer&lt;EntityManager&gt; action){&#10;        EntityManager em = PersistenceManager.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try{&#10;            tx.begin();// Inicia la transacción&#10;            action.accept(em);// Ejecuta la acción principal&#10;            tx.commit(); // Confirma los cambios&#10;            Logger.debug(&quot;TransactionUtil&quot;, &quot;Transacción completada exitosamente&quot;);&#10;        }catch (Exception e){&#10;            if(tx.isActive()) {&#10;                tx.rollback();// Revierte en caso de error&#10;                Logger.warn(&quot;TransactionUtil&quot;, &quot;Transacción revertida debido a error: &quot; + e.getMessage());&#10;            }&#10;            Logger.error(&quot;TransactionUtil&quot;, &quot;Transacción fallida&quot;, e);&#10;            throw new RuntimeException(&quot;Transacción fallida&quot;, e);&#10;        }finally {&#10;            if(em.isOpen()) em.close();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Ejecuta una función con EntityManager y retorna un resultado dentro de una transacción.&#10;     * Se recomienda para consultas complejas que necesitan transacción.&#10;     */&#10;    public static &lt;T&gt; T executeInTransactionWithResult(Function&lt;EntityManager, T&gt; function){&#10;        EntityManager em = PersistenceManager.getEntityManager();&#10;        EntityTransaction tx = em.getTransaction();&#10;&#10;        try{&#10;            tx.begin();&#10;            T result = function.apply(em);&#10;            tx.commit();&#10;            Logger.debug(&quot;TransactionUtil&quot;, &quot;Transacción con resultado completada exitosamente&quot;);&#10;            return result;&#10;        }catch (Exception e){&#10;            if(tx.isActive()) {&#10;                tx.rollback();&#10;                Logger.warn(&quot;TransactionUtil&quot;, &quot;Transacción con resultado revertida: &quot; + e.getMessage());&#10;            }&#10;            Logger.error(&quot;TransactionUtil&quot;, &quot;Transacción con resultado fallida&quot;, e);&#10;            throw new RuntimeException(&quot;Transacción fallida&quot;, e);&#10;        }finally {&#10;            if(em.isOpen()) em.close();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/dependency/DependencyContainer.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/dependency/DependencyContainer.java" />
              <option name="originalContent" value="package com.libraryManagement.config.dependency;&#10;&#10;import com.libraryManagement.repository.impl.UserRepositoryImpl;&#10;import com.libraryManagement.repository.interfaces.UserRepository;&#10;import com.libraryManagement.service.UserServiceImpl;&#10;import com.libraryManagement.service.interfaces.UserService;&#10;import com.libraryManagement.controller.UserController;&#10;import com.libraryManagement.mapper.UserMapper;&#10;import com.libraryManagement.mapper.factory.MapperFactory;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * CONTENEDOR DE DEPENDENCIAS ESCALABLE&#10; * Estructura profesional que soporta múltiples entidades sin explotar en complejidad&#10; */&#10;public class DependencyContainer {&#10;&#10;    // =====================================================================&#10;    // ALMACENAMIENTO GENÉRICO POR TIPO&#10;    // =====================================================================&#10;&#10;    private final Map&lt;Class&lt;?&gt;, Object&gt; repositories = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Object&gt; services = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Object&gt; mappers = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Object&gt; controllers = new HashMap&lt;&gt;();&#10;&#10;    private MapperFactory mapperFactory;&#10;&#10;    // =====================================================================&#10;    // INICIALIZACIÓN MODULAR&#10;    // =====================================================================&#10;&#10;    public void initializeDependencies() {&#10;        // 1. Inicializar Factory de Mappers&#10;        initializeMapperFactory();&#10;&#10;        // 2. Inicializar por módulos&#10;        initializeUserModule();&#10;        // initializeBookModule();    // Futuro&#10;        // initializeLoanModule();    // Futuro&#10;&#10;        System.out.println(&quot;✅ Dependencias inicializadas correctamente&quot;);&#10;    }&#10;&#10;    private void initializeMapperFactory() {&#10;        mapperFactory = MapperFactory.getInstance();&#10;    }&#10;&#10;    /**&#10;     * MÓDULO USER - Agrupa todas las dependencias de User&#10;     */&#10;    private void initializeUserModule() {&#10;        // Mappers&#10;        var userMapper = mapperFactory.getMapper(UserMapper.class);&#10;        mappers.put(UserMapper.class, userMapper);&#10;&#10;        // Repositories&#10;        var userRepository = new UserRepositoryImpl();&#10;        repositories.put(UserRepository.class, userRepository);&#10;&#10;        // Services - ✅ DECLARAR COMO INTERFACE&#10;        UserService userService = new UserServiceImpl((UserRepository) userRepository,&#10;            userMapper&#10;        );&#10;        services.put(UserService.class, userService);&#10;&#10;        // Controllers&#10;        var userController = new UserController(userService);&#10;        controllers.put(UserController.class, userController);&#10;&#10;        System.out.println(&quot; User module initialized&quot;);&#10;    }&#10;&#10;    // =====================================================================&#10;    // ACCESO GENÉRICO Y TIPADO&#10;    // =====================================================================&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; T getRepository(Class&lt;T&gt; repositoryClass) {&#10;        return (T) repositories.get(repositoryClass);&#10;    }&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; T getService(Class&lt;T&gt; serviceClass) {&#10;        return (T) services.get(serviceClass);&#10;    }&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; T getController(Class&lt;T&gt; controllerClass) {&#10;        return (T) controllers.get(controllerClass);&#10;    }&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; T getMapper(Class&lt;T&gt; mapperClass) {&#10;        return (T) mappers.get(mapperClass);&#10;    }&#10;&#10;    public MapperFactory getMapperFactory() {&#10;        return mapperFactory;&#10;    }&#10;&#10;    public void shutdown() {&#10;        repositories.clear();&#10;        services.clear();&#10;        mappers.clear();&#10;        controllers.clear();&#10;        System.out.println(&quot; Dependencias liberadas&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.libraryManagement.config.dependency;&#10;&#10;import com.libraryManagement.repository.impl.UserRepositoryImpl;&#10;import com.libraryManagement.repository.interfaces.UserRepository;&#10;import com.libraryManagement.service.UserServiceImpl;&#10;import com.libraryManagement.service.interfaces.UserService;&#10;import com.libraryManagement.controller.UserController;&#10;import com.libraryManagement.mapper.UserMapper;&#10;import com.libraryManagement.mapper.factory.MapperFactory;&#10;import com.libraryManagement.util.Logger; // ← AGREGADO: Logger profesional&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;/**&#10; * CONTENEDOR DE DEPENDENCIAS ESCALABLE&#10; * Estructura profesional que soporta múltiples entidades sin explotar en complejidad&#10; */&#10;public class DependencyContainer {&#10;&#10;    // =====================================================================&#10;    // ALMACENAMIENTO GENÉRICO POR TIPO&#10;    // =====================================================================&#10;&#10;    private final Map&lt;Class&lt;?&gt;, Object&gt; repositories = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Object&gt; services = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Object&gt; mappers = new HashMap&lt;&gt;();&#10;    private final Map&lt;Class&lt;?&gt;, Object&gt; controllers = new HashMap&lt;&gt;();&#10;&#10;    private MapperFactory mapperFactory;&#10;&#10;    // =====================================================================&#10;    // INICIALIZACIÓN MODULAR&#10;    // =====================================================================&#10;&#10;    public void initializeDependencies() {&#10;        // 1. Inicializar Factory de Mappers&#10;        initializeMapperFactory();&#10;&#10;        // 2. Inicializar por módulos&#10;        initializeUserModule();&#10;        // initializeBookModule();    // Futuro&#10;        // initializeLoanModule();    // Futuro&#10;&#10;        Logger.success(&quot;DependencyContainer&quot;, &quot;Dependencias inicializadas correctamente&quot;);&#10;    }&#10;&#10;    private void initializeMapperFactory() {&#10;        Logger.info(&quot;DependencyContainer&quot;, &quot;Inicializando mappers...&quot;);&#10;        mapperFactory = MapperFactory.getInstance();&#10;        Logger.success(&quot;DependencyContainer&quot;, &quot;Todos los mappers inicializados&quot;);&#10;    }&#10;&#10;    /**&#10;     * MÓDULO USER - Agrupa todas las dependencias de User&#10;     */&#10;    private void initializeUserModule() {&#10;        // Mappers&#10;        var userMapper = mapperFactory.getMapper(UserMapper.class);&#10;        mappers.put(UserMapper.class, userMapper);&#10;&#10;        // Repositories&#10;        var userRepository = new UserRepositoryImpl();&#10;        repositories.put(UserRepository.class, userRepository);&#10;&#10;        // Services - ✅ DECLARAR COMO INTERFACE&#10;        UserService userService = new UserServiceImpl((UserRepository) userRepository,&#10;            userMapper&#10;        );&#10;        services.put(UserService.class, userService);&#10;&#10;        // Controllers&#10;        var userController = new UserController(userService);&#10;        controllers.put(UserController.class, userController);&#10;&#10;        Logger.success(&quot;DependencyContainer&quot;, &quot;User module initialized&quot;);&#10;    }&#10;&#10;    // =====================================================================&#10;    // ACCESO GENÉRICO Y TIPADO&#10;    // =====================================================================&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; T getRepository(Class&lt;T&gt; repositoryClass) {&#10;        return (T) repositories.get(repositoryClass);&#10;    }&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; T getService(Class&lt;T&gt; serviceClass) {&#10;        return (T) services.get(serviceClass);&#10;    }&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; T getController(Class&lt;T&gt; controllerClass) {&#10;        return (T) controllers.get(controllerClass);&#10;    }&#10;&#10;    @SuppressWarnings(&quot;unchecked&quot;)&#10;    public &lt;T&gt; T getMapper(Class&lt;T&gt; mapperClass) {&#10;        return (T) mappers.get(mapperClass);&#10;    }&#10;&#10;    public MapperFactory getMapperFactory() {&#10;        return mapperFactory;&#10;    }&#10;&#10;    public void shutdown() {&#10;        repositories.clear();&#10;        services.clear();&#10;        mappers.clear();&#10;        controllers.clear();&#10;        Logger.info(&quot;DependencyContainer&quot;, &quot;Dependencias liberadas&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/server/RouteRegistry.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/server/RouteRegistry.java" />
              <option name="originalContent" value="package com.libraryManagement.config.server;&#10;&#10;import com.sun.net.httpserver.HttpServer;&#10;import com.libraryManagement.controller.UserController;&#10;&#10;/**&#10; * Registro centralizado de rutas y endpoints&#10; * Responsabilidad: Mapear URLs a controladores específicos&#10; */&#10;public class RouteRegistry {&#10;&#10;    private final HttpServer server;&#10;&#10;    public RouteRegistry(HttpServer server) {&#10;        this.server = server;&#10;    }&#10;&#10;    /**&#10;     * Registra todas las rutas de la aplicación&#10;     * @param userController el controlador de usuarios&#10;     */&#10;    public void registerRoutes(UserController userController) {&#10;        // Rutas de usuarios&#10;        registerUserRoutes(userController);&#10;&#10;        // Ruta de health check&#10;        registerHealthCheck();&#10;&#10;        // Aquí se agregarán más rutas cuando se creen otros controladores&#10;        // registerBookRoutes(bookController);&#10;        // registerLoanRoutes(loanController);&#10;    }&#10;&#10;    /**&#10;     * Registra las rutas específicas de usuarios&#10;     */&#10;    private void registerUserRoutes(UserController userController) {&#10;        server.createContext(&quot;/api/users&quot;, userController);&#10;&#10;        // Rutas adicionales si las necesitas:&#10;        // server.createContext(&quot;/api/users/search&quot;, userController);&#10;        // server.createContext(&quot;/api/users/statistics&quot;, userController);&#10;    }&#10;&#10;    /**&#10;     * Registra endpoint de health check para monitoreo&#10;     */&#10;    private void registerHealthCheck() {&#10;        server.createContext(&quot;/health&quot;, exchange -&gt; {&#10;            String response = &quot;{\&quot;status\&quot;:\&quot;UP\&quot;,\&quot;service\&quot;:\&quot;Library Management API\&quot;}&quot;;&#10;            exchange.getResponseHeaders().set(&quot;Content-Type&quot;, &quot;application/json&quot;);&#10;            exchange.sendResponseHeaders(200, response.getBytes().length);&#10;            exchange.getResponseBody().write(response.getBytes());&#10;            exchange.getResponseBody().close();&#10;        });&#10;    }&#10;&#10;    /**&#10;     * Obtiene información sobre las rutas registradas&#10;     */&#10;    public void printRegisteredRoutes() {&#10;        System.out.println(&quot; Rutas registradas:&quot;);&#10;        System.out.println(&quot;   GET/POST/PUT/DELETE /api/users - Gestión de usuarios&quot;);&#10;        System.out.println(&quot;   GET /health - Health check&quot;);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.libraryManagement.config.server;&#13;&#10;&#13;&#10;import com.libraryManagement.util.Logger; // ← AGREGADO: Logger profesional&#13;&#10;import com.sun.net.httpserver.HttpServer;&#13;&#10;import com.libraryManagement.controller.UserController;&#13;&#10;&#13;&#10;/**&#13;&#10; * Registro centralizado de rutas y endpoints&#13;&#10; * Responsabilidad: Mapear URLs a controladores específicos&#13;&#10; */&#13;&#10;public class RouteRegistry {&#13;&#10;&#13;&#10;    private final HttpServer server;&#13;&#10;&#13;&#10;    public RouteRegistry(HttpServer server) {&#13;&#10;        this.server = server;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Registra todas las rutas de usuarios&#13;&#10;     */&#13;&#10;    public void registerUserRoutes(UserController userController) {&#13;&#10;        Logger.debug(&quot;RouteRegistry&quot;, &quot;Registrando rutas de usuarios...&quot;);&#13;&#10;        server.createContext(&quot;/api/users&quot;, userController);&#13;&#10;        Logger.info(&quot;RouteRegistry&quot;, &quot;Rutas de usuarios registradas en /api/users&quot;);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Registra endpoint de health check para monitoreo&#13;&#10;     */&#13;&#10;    public void registerHealthCheck() {&#13;&#10;        Logger.debug(&quot;RouteRegistry&quot;, &quot;Registrando health check...&quot;);&#13;&#10;        server.createContext(&quot;/health&quot;, exchange -&gt; {&#13;&#10;            String response = &quot;{\&quot;status\&quot;:\&quot;UP\&quot;,\&quot;service\&quot;:\&quot;Library Management API\&quot;}&quot;;&#13;&#10;            exchange.getResponseHeaders().set(&quot;Content-Type&quot;, &quot;application/json&quot;);&#13;&#10;            exchange.sendResponseHeaders(200, response.getBytes().length);&#13;&#10;            exchange.getResponseBody().write(response.getBytes());&#13;&#10;            exchange.getResponseBody().close();&#13;&#10;        });&#13;&#10;        Logger.info(&quot;RouteRegistry&quot;, &quot;Health check registrado en /health&quot;);&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/server/ServerConfiguration.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/config/server/ServerConfiguration.java" />
              <option name="originalContent" value="package com.libraryManagement.config.server;&#10;&#10;import com.sun.net.httpserver.HttpServer;&#10;import java.io.IOException;&#10;import java.net.InetSocketAddress;&#10;import java.util.concurrent.Executors;&#10;&#10;/**&#10; * Configuración del servidor HTTP&#10; * Responsabilidad: Crear y configurar el servidor HTTP con sus parámetros&#10; */&#10;public class ServerConfiguration {&#10;&#10;    private static final int DEFAULT_PORT = 8080;&#10;    private static final int DEFAULT_BACKLOG = 0; // Sin límite de conexiones pendientes&#10;    private static final int THREAD_POOL_SIZE = 10;&#10;&#10;    private final int port;&#10;    private final int backlog;&#10;    private final int threadPoolSize;&#10;&#10;    // Constructor con valores por defecto&#10;    public ServerConfiguration() {&#10;        this(DEFAULT_PORT, DEFAULT_BACKLOG, THREAD_POOL_SIZE);&#10;    }&#10;&#10;    // Constructor personalizable&#10;    public ServerConfiguration(int port, int backlog, int threadPoolSize) {&#10;        this.port = port;&#10;        this.backlog = backlog;&#10;        this.threadPoolSize = threadPoolSize;&#10;    }&#10;&#10;    /**&#10;     * Crea y configura el servidor HTTP&#10;     * @return HttpServer configurado pero no iniciado&#10;     * @throws IOException si hay error al crear el servidor&#10;     */&#10;    public HttpServer createServer() throws IOException {&#10;        // Crear el servidor HTTP en la dirección y puerto especificados&#10;        HttpServer server = HttpServer.create(new InetSocketAddress(port), backlog);&#10;&#10;        // Configurar pool de hilos para manejar requests concurrentes&#10;        server.setExecutor(Executors.newFixedThreadPool(threadPoolSize));&#10;&#10;        return server;&#10;    }&#10;&#10;    // Getters para acceso a configuración&#10;    public int getPort() { return port; }&#10;    public int getBacklog() { return backlog; }&#10;    public int getThreadPoolSize() { return threadPoolSize; }&#10;}&#10;" />
              <option name="updatedContent" value="package com.libraryManagement.config.server;&#13;&#10;&#13;&#10;import com.libraryManagement.util.Logger; // ← AGREGADO: Logger profesional&#13;&#10;import com.sun.net.httpserver.HttpServer;&#13;&#10;import java.io.IOException;&#13;&#10;import java.net.InetSocketAddress;&#13;&#10;import java.util.concurrent.Executors;&#13;&#10;&#13;&#10;/**&#13;&#10; * Configuración del servidor HTTP&#13;&#10; * Responsabilidad: Crear y configurar el servidor HTTP con sus parámetros&#13;&#10; */&#13;&#10;public class ServerConfiguration {&#13;&#10;&#13;&#10;    private static final int DEFAULT_PORT = 8080;&#13;&#10;    private static final int DEFAULT_BACKLOG = 0; // Sin límite de conexiones pendientes&#13;&#10;    private static final int THREAD_POOL_SIZE = 10;&#13;&#10;&#13;&#10;    private final int port;&#13;&#10;    private final int backlog;&#13;&#10;    private final int threadPoolSize;&#13;&#10;&#13;&#10;    // Constructor con valores por defecto&#13;&#10;    public ServerConfiguration() {&#13;&#10;        this(DEFAULT_PORT, DEFAULT_BACKLOG, THREAD_POOL_SIZE);&#13;&#10;    }&#13;&#10;&#13;&#10;    // Constructor personalizable&#13;&#10;    public ServerConfiguration(int port, int backlog, int threadPoolSize) {&#13;&#10;        this.port = port;&#13;&#10;        this.backlog = backlog;&#13;&#10;        this.threadPoolSize = threadPoolSize;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Crea y configura el servidor HTTP&#13;&#10;     */&#13;&#10;    public HttpServer createServer() throws IOException {&#13;&#10;        try {&#13;&#10;            Logger.debug(&quot;ServerConfiguration&quot;, &quot;Creando servidor en puerto &quot; + port);&#13;&#10;            &#13;&#10;            HttpServer server = HttpServer.create(new InetSocketAddress(port), backlog);&#13;&#10;            &#13;&#10;            // Configurar pool de threads&#13;&#10;            server.setExecutor(Executors.newFixedThreadPool(threadPoolSize));&#13;&#10;            &#13;&#10;            Logger.success(&quot;ServerConfiguration&quot;, &quot;Servidor HTTP creado exitosamente - Puerto: &quot; + port + &quot;, Threads: &quot; + threadPoolSize);&#13;&#10;            return server;&#13;&#10;            &#13;&#10;        } catch (IOException e) {&#13;&#10;            Logger.error(&quot;ServerConfiguration&quot;, &quot;Error creando servidor HTTP en puerto &quot; + port, e);&#13;&#10;            throw e;&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Getters&#13;&#10;    public int getPort() { return port; }&#13;&#10;    public int getBacklog() { return backlog; }&#13;&#10;    public int getThreadPoolSize() { return threadPoolSize; }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/domain/user/UserUtils.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/domain/user/UserUtils.java" />
              <option name="updatedContent" value="package com.libraryManagement.domain.user;&#10;&#10;import com.libraryManagement.model.User;&#10;import com.libraryManagement.model.Address;&#10;import java.time.LocalDate;&#10;import java.time.Period;&#10;&#10;/**&#10; * UTILIDADES ESPECÍFICAS DEL DOMINIO USER&#10; * &#10; * Solo contiene cálculos y transformaciones específicas&#10; * de la entidad User que NO son validaciones de negocio&#10; */&#10;public class UserUtils {&#10;&#10;    /**&#10;     * Calcula la edad basada en fecha de nacimiento&#10;     */&#10;    public static Integer calculateAge(LocalDate dateOfBirth) {&#10;        if (dateOfBirth == null) {&#10;            return null;&#10;        }&#10;&#10;        LocalDate now = LocalDate.now();&#10;        if (dateOfBirth.isAfter(now)) {&#10;            return 0; // Fecha futura = 0 años&#10;        }&#10;&#10;        return Period.between(dateOfBirth, now).getYears();&#10;    }&#10;&#10;    /**&#10;     * Extrae el nombre de ciudad de una dirección&#10;     */&#10;    public static String extractCityName(Address address) {&#10;        if (address == null) {&#10;            return null;&#10;        }&#10;        return address.getCity();&#10;    }&#10;&#10;    /**&#10;     * Formatea nombre completo del usuario&#10;     */&#10;    public static String formatFullName(String firstName, String lastName) {&#10;        if (firstName == null &amp;&amp; lastName == null) {&#10;            return &quot;Nombre no disponible&quot;;&#10;        }&#10;        &#10;        String first = firstName != null ? firstName.trim() : &quot;&quot;;&#10;        String last = lastName != null ? lastName.trim() : &quot;&quot;;&#10;        &#10;        if (first.isEmpty() &amp;&amp; last.isEmpty()) {&#10;            return &quot;Nombre no disponible&quot;;&#10;        }&#10;        &#10;        return (first + &quot; &quot; + last).trim();&#10;    }&#10;&#10;    /**&#10;     * Calcula estado de membresía basado en el estado del usuario&#10;     * &#10;     * NOTA: Este es un cálculo, no una validación de negocio&#10;     */&#10;    public static String calculateMembershipStatus(User user) {&#10;        if (user == null || user.getLoans() == null) {&#10;            return &quot;ACTIVE&quot;;&#10;        }&#10;&#10;        // Contar préstamos activos&#10;        long activeLoans = user.getLoans().stream()&#10;            .filter(loan -&gt; loan.getReturnedAt() == null)&#10;            .count();&#10;&#10;        // Verificar préstamos vencidos&#10;        boolean hasOverdueLoans = user.getLoans().stream()&#10;            .filter(loan -&gt; loan.getReturnedAt() == null)&#10;            .anyMatch(loan -&gt; loan.getDueDate().isBefore(LocalDate.now()));&#10;&#10;        if (hasOverdueLoans) {&#10;            return &quot;SUSPENDED&quot;;&#10;        } else if (activeLoans &gt;= 3) {&#10;            return &quot;LIMITED&quot;;&#10;        } else {&#10;            return &quot;ACTIVE&quot;;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/exception/response/ErrorResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/exception/response/ErrorResponse.java" />
              <option name="originalContent" value="package com.libraryManagement.exception.response;&#10;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;import com.fasterxml.jackson.annotation.JsonFormat;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;/**&#10; * RESPUESTA ESTÁNDAR DE ERROR&#10; *&#10; * Estructura unificada para todas las respuestas de error de la API&#10; */&#10;@Data&#10;@Builder&#10;public class ErrorResponse {&#10;&#10;    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)&#10;    private LocalDateTime timestamp;&#10;&#10;    private int status;&#10;    private String error;&#10;    private String message;&#10;    private String operation;&#10;    private String path;&#10;&#10;    /**&#10;     * Crear respuesta de error simple&#10;     */&#10;    public static ErrorResponse simple(String message, int status) {&#10;        return ErrorResponse.builder()&#10;            .timestamp(LocalDateTime.now())&#10;            .status(status)&#10;            .error(getHttpStatusText(status))&#10;            .message(message)&#10;            .build();&#10;    }&#10;&#10;    /**&#10;     * Crear respuesta de error completa&#10;     */&#10;    public static ErrorResponse complete(String message, int status, String operation, String path) {&#10;        return ErrorResponse.builder()&#10;            .timestamp(LocalDateTime.now())&#10;            .status(status)&#10;            .error(getHttpStatusText(status))&#10;            .message(message)&#10;            .operation(operation)&#10;            .path(path)&#10;            .build();&#10;    }&#10;&#10;    private static String getHttpStatusText(int status) {&#10;        return switch (status) {&#10;            case 400 -&gt; &quot;Bad Request&quot;;&#10;            case 401 -&gt; &quot;Unauthorized&quot;;&#10;            case 403 -&gt; &quot;Forbidden&quot;;&#10;            case 404 -&gt; &quot;Not Found&quot;;&#10;            case 409 -&gt; &quot;Conflict&quot;;&#10;            case 422 -&gt; &quot;Unprocessable Entity&quot;;&#10;            case 500 -&gt; &quot;Internal Server Error&quot;;&#10;            default -&gt; &quot;Error&quot;;&#10;        };&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.libraryManagement.exception.response;&#13;&#10;&#13;&#10;import lombok.Builder;&#13;&#10;import lombok.Data;&#13;&#10;import com.fasterxml.jackson.annotation.JsonFormat;&#13;&#10;&#13;&#10;import java.time.LocalDateTime;&#13;&#10;&#13;&#10;/**&#13;&#10; * RESPUESTA ESTÁNDAR DE ERROR&#13;&#10; *&#13;&#10; * Estructura unificada para todas las respuestas de error de la API&#13;&#10; */&#13;&#10;@Data&#13;&#10;@Builder&#13;&#10;public class ErrorResponse {&#13;&#10;&#13;&#10;    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)&#13;&#10;    private LocalDateTime timestamp;&#13;&#10;&#13;&#10;    private int status;&#13;&#10;    private String error;&#13;&#10;    private String message;&#13;&#10;    private String operation;&#13;&#10;    private String path;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Crear respuesta de error simple&#13;&#10;     */&#13;&#10;    public static ErrorResponse simple(String message, int status) {&#13;&#10;        return ErrorResponse.builder()&#13;&#10;            .timestamp(LocalDateTime.now())&#13;&#10;            .status(status)&#13;&#10;            .error(getHttpStatusText(status))&#13;&#10;            .message(message)&#13;&#10;            .build();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Crear respuesta de error completa&#13;&#10;     */&#13;&#10;    public static ErrorResponse complete(String message, int status, String operation, String path) {&#13;&#10;        return ErrorResponse.builder()&#13;&#10;            .timestamp(LocalDateTime.now())&#13;&#10;            .status(status)&#13;&#10;            .error(getHttpStatusText(status))&#13;&#10;            .message(message)&#13;&#10;            .operation(operation)&#13;&#10;            .path(path)&#13;&#10;            .build();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Convierte código HTTP a texto descriptivo&#13;&#10;     */&#13;&#10;    private static String getHttpStatusText(int status) {&#13;&#10;        return switch (status) {&#13;&#10;            case 400 -&gt; &quot;Bad Request&quot;;&#13;&#10;            case 401 -&gt; &quot;Unauthorized&quot;;&#13;&#10;            case 403 -&gt; &quot;Forbidden&quot;;&#13;&#10;            case 404 -&gt; &quot;Not Found&quot;;&#13;&#10;            case 409 -&gt; &quot;Conflict&quot;;&#13;&#10;            case 422 -&gt; &quot;Unprocessable Entity&quot;;&#13;&#10;            case 500 -&gt; &quot;Internal Server Error&quot;;&#13;&#10;            case 503 -&gt; &quot;Service Unavailable&quot;;&#13;&#10;            default -&gt; &quot;Error&quot;;&#13;&#10;        };&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/mapper/context/UserMappingContext.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/mapper/context/UserMappingContext.java" />
              <option name="originalContent" value="package com.libraryManagement.mapper.context;&#10;&#10;import lombok.Builder;&#10;import lombok.Data;&#10;&#10;/**&#10; * CONTEXTO ESPECÍFICO PARA USER&#10; * Utiliza el BaseMappingContext existente como base&#10; */&#10;@Data&#10;@Builder&#10;public class UserMappingContext {&#10;&#10;    // =====================================================================&#10;    // FACTORY METHODS - CONTEXTOS PREDEFINIDOS PARA USER&#10;    // =====================================================================&#10;&#10;    public static BaseMappingContext basic() {&#10;        return BaseMappingContext.builder()&#10;                .includeCalculatedFields(false)&#10;                .includeAddress(false)&#10;                .includeLoans(false)&#10;                .build();&#10;    }&#10;&#10;    public static BaseMappingContext withAddress() {&#10;        return BaseMappingContext.builder()&#10;                .includeCalculatedFields(true)&#10;                .includeAddress(true)&#10;                .includeLoans(false)&#10;                .build();&#10;    }&#10;&#10;    public static BaseMappingContext profile() {&#10;        return BaseMappingContext.builder()&#10;                .includeCalculatedFields(true)&#10;                .includeAddress(true)&#10;                .includeLoanStats(true)&#10;                .includeLoans(false)&#10;                .build();&#10;    }&#10;&#10;    public static BaseMappingContext admin() {&#10;        return BaseMappingContext.builder()&#10;                .includeCalculatedFields(true)&#10;                .includeAddress(true)&#10;                .includeLoans(true)&#10;                .includeLoanStats(true)&#10;                .includeFullDetails(true)&#10;                .build();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.libraryManagement.mapper.context;&#13;&#10;&#13;&#10;import lombok.Builder;&#13;&#10;import lombok.Data;&#13;&#10;&#13;&#10;/**&#13;&#10; * CONTEXTO ESPECÍFICO PARA USER&#13;&#10; * Utiliza el BaseMappingContext existente como base&#13;&#10; */&#13;&#10;@Data&#13;&#10;@Builder&#13;&#10;public class UserMappingContext {&#13;&#10;&#13;&#10;    // =====================================================================&#13;&#10;    // FACTORY METHODS - CONTEXTOS PREDEFINIDOS PARA USER&#13;&#10;    // =====================================================================&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Contexto simple - solo datos básicos sin relaciones&#13;&#10;     */&#13;&#10;    public static BaseMappingContext simple() {&#13;&#10;        return BaseMappingContext.builder()&#13;&#10;                .includeCalculatedFields(false)&#13;&#10;                .includeAddress(false)&#13;&#10;                .includeLoans(false)&#13;&#10;                .includeLoanStats(false)&#13;&#10;                .includeFullDetails(false)&#13;&#10;                .build();&#13;&#10;    }&#13;&#10;&#13;&#10;    public static BaseMappingContext basic() {&#13;&#10;        return BaseMappingContext.builder()&#13;&#10;                .includeCalculatedFields(false)&#13;&#10;                .includeAddress(false)&#13;&#10;                .includeLoans(false)&#13;&#10;                .build();&#13;&#10;    }&#13;&#10;&#13;&#10;    public static BaseMappingContext withAddress() {&#13;&#10;        return BaseMappingContext.builder()&#13;&#10;                .includeCalculatedFields(true)&#13;&#10;                .includeAddress(true)&#13;&#10;                .includeLoans(false)&#13;&#10;                .build();&#13;&#10;    }&#13;&#10;&#13;&#10;    public static BaseMappingContext profile() {&#13;&#10;        return BaseMappingContext.builder()&#13;&#10;                .includeCalculatedFields(true)&#13;&#10;                .includeAddress(true)&#13;&#10;                .includeLoanStats(true)&#13;&#10;                .includeLoans(false)&#13;&#10;                .build();&#13;&#10;    }&#13;&#10;&#13;&#10;    public static BaseMappingContext admin() {&#13;&#10;        return BaseMappingContext.builder()&#13;&#10;                .includeCalculatedFields(true)&#13;&#10;                .includeAddress(true)&#13;&#10;                .includeLoans(true)&#13;&#10;                .includeLoanStats(true)&#13;&#10;                .includeFullDetails(true)&#13;&#10;                .build();&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/repository/impl/UserRepositoryImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/repository/impl/UserRepositoryImpl.java" />
              <option name="originalContent" value="package com.libraryManagement.repository.impl;&#10;&#10;import com.libraryManagement.config.db.TransactionUtil;&#10;import com.libraryManagement.exception.repository.RepositoryException;&#10;import com.libraryManagement.model.User;&#10;import com.libraryManagement.repository.interfaces.UserRepository;&#10;import jakarta.persistence.NoResultException;&#10;import jakarta.persistence.TypedQuery;&#10;&#10;import java.time.LocalDate;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;/**&#10; * IMPLEMENTACIÓN PROFESIONAL DE UserRepository&#10; * USANDO JPA + TransactionUtil OPTIMIZADO&#10; *&#10; * Orden de métodos:&#10; * 1. Métodos de GenericRepository (CRUD básico)&#10; * 2. Métodos específicos de UserRepository (en orden de interface)&#10; */&#10;public class UserRepositoryImpl implements UserRepository {&#10;&#10;    // =====================================================================&#10;    // MÉTODOS DE GENERIC REPOSITORY - CON JPA + TransactionUtil OPTIMIZADO&#10;    // =====================================================================&#10;&#10;    @Override&#10;    public User save(User user) {&#10;        try {&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    return em.merge(user);&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error al guardar usuario&quot;, &quot;SAVE&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado al guardar usuario&quot;, &quot;SAVE&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Optional&lt;User&gt; findById(Long id) {&#10;        try {&#10;            User user = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    return em.find(User.class, id);&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error consultando usuario por ID: &quot; + id, &quot;FIND&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;            return Optional.ofNullable(user);&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado consultando usuario por ID: &quot; + id, &quot;FIND&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;User&gt; findAll() {&#10;        try {&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#10;                        &quot;SELECT u FROM User u ORDER BY u.lastName, u.firstName&quot;, User.class);&#10;                    return query.getResultList();&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error consultando todos los usuarios&quot;, &quot;FIND_ALL&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado consultando todos los usuarios&quot;, &quot;FIND_ALL&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void update(User user) {&#10;        try {&#10;            TransactionUtil.executeInTransaction(em -&gt; {&#10;                try {&#10;                    em.merge(user);&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error al actualizar usuario&quot;, &quot;UPDATE&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado al actualizar usuario&quot;, &quot;UPDATE&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void delete(User user) {&#10;        try {&#10;            TransactionUtil.executeInTransaction(em -&gt; {&#10;                try {&#10;                    User managedUser = em.merge(user);&#10;                    em.remove(managedUser);&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error al eliminar usuario&quot;, &quot;DELETE&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado al eliminar usuario&quot;, &quot;DELETE&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public boolean existsById(Long id) {&#10;        try {&#10;            Long count = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;Long&gt; query = em.createQuery(&#10;                        &quot;SELECT COUNT(u.id) FROM User u WHERE u.id = :id&quot;, Long.class);&#10;                    query.setParameter(&quot;id&quot;, id);&#10;                    return query.getSingleResult();&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error verificando existencia de usuario por ID: &quot; + id, &quot;EXISTS&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;            return count &gt; 0;&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado verificando existencia por ID: &quot; + id, &quot;EXISTS&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    // =====================================================================&#10;    // BÚSQUEDAS ÚNICAS User&#10;    // =====================================================================&#10;&#10;    @Override&#10;    public Optional&lt;User&gt; findByEmail(String email) {&#10;        try {&#10;            User user = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#10;                        &quot;SELECT u FROM User u WHERE u.email = :email&quot;, User.class);&#10;                    query.setParameter(&quot;email&quot;, email);&#10;                    return query.getSingleResult();&#10;                } catch (NoResultException e) {&#10;                    return null;&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error consultando usuario por email: &quot; + email, &quot;FIND_BY_EMAIL&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;            return Optional.ofNullable(user);&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado consultando por email: &quot; + email, &quot;FIND_BY_EMAIL&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Optional&lt;User&gt; findByDni(String dni) {&#10;        try {&#10;            User user = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#10;                        &quot;SELECT u FROM User u WHERE u.dni = :dni&quot;, User.class);&#10;                    query.setParameter(&quot;dni&quot;, dni);&#10;                    return query.getSingleResult();&#10;                } catch (NoResultException e) {&#10;                    return null;&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error consultando usuario por DNI: &quot; + dni, &quot;FIND_BY_DNI&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;            return Optional.ofNullable(user);&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado consultando por DNI: &quot; + dni, &quot;FIND_BY_DNI&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    // =====================================================================&#10;    // VALIDACIONES DE EXISTENCIA CON JPA&#10;    // =====================================================================&#10;&#10;    @Override&#10;    public boolean existsByEmail(String email) {&#10;        try {&#10;            Long count = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;Long&gt; query = em.createQuery(&#10;                        &quot;SELECT COUNT(u.id) FROM User u WHERE u.email = :email&quot;, Long.class);&#10;                    query.setParameter(&quot;email&quot;, email);&#10;                    return query.getSingleResult();&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error verificando existencia de email: &quot; + email, &quot;EXISTS_BY_EMAIL&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;            return count &gt; 0;&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado verificando email: &quot; + email, &quot;EXISTS_BY_EMAIL&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public boolean existsByDni(String dni) {&#10;        try {&#10;            Long count = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;Long&gt; query = em.createQuery(&#10;                        &quot;SELECT COUNT(u.id) FROM User u WHERE u.dni = :dni&quot;, Long.class);&#10;                    query.setParameter(&quot;dni&quot;, dni);&#10;                    return query.getSingleResult();&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error verificando existencia de DNI: &quot; + dni, &quot;EXISTS_BY_DNI&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;            return count &gt; 0;&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado verificando DNI: &quot; + dni, &quot;EXISTS_BY_DNI&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    // =====================================================================&#10;    // BÚSQUEDAS MÚLTIPLES CON JPA&#10;    // =====================================================================&#10;&#10;    @Override&#10;    public List&lt;User&gt; findByActiveLoans() {&#10;        try {&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#10;                        &quot;SELECT DISTINCT u FROM User u JOIN u.loans l WHERE l.returnedAt IS NULL&quot;, User.class);&#10;                    return query.getResultList();&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error consultando usuarios con préstamos activos&quot;, &quot;FIND_BY_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado consultando usuarios con préstamos activos&quot;, &quot;FIND_BY_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;User&gt; findByOverdueLoans() {&#10;        try {&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#10;                        &quot;SELECT DISTINCT u FROM User u JOIN u.loans l WHERE l.returnedAt IS NULL AND l.dueDate &lt; :today&quot;, User.class);&#10;                    query.setParameter(&quot;today&quot;, LocalDate.now());&#10;                    return query.getResultList();&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error consultando usuarios con préstamos vencidos&quot;, &quot;FIND_BY_OVERDUE_LOANS&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado consultando usuarios con préstamos vencidos&quot;, &quot;FIND_BY_OVERDUE_LOANS&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    // =====================================================================&#10;    // PAGINACIÓN CON JPA&#10;    // =====================================================================&#10;&#10;    @Override&#10;    public List&lt;User&gt; findPaginated(int page, int size) {&#10;        try {&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#10;                        &quot;SELECT u FROM User u ORDER BY u.lastName, u.firstName&quot;, User.class);&#10;                    query.setFirstResult(page * size);&#10;                    query.setMaxResults(size);&#10;                    return query.getResultList();&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error en consulta paginada&quot;, &quot;FIND_PAGINATED&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado en consulta paginada&quot;, &quot;FIND_PAGINATED&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;User&gt; searchByName(String namePattern, int page, int size) {&#10;        try {&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#10;                        &quot;SELECT u FROM User u WHERE LOWER(CONCAT(u.firstName, ' ', u.lastName)) LIKE LOWER(:pattern) ORDER BY u.lastName, u.firstName&quot;, User.class);&#10;                    query.setParameter(&quot;pattern&quot;, &quot;%&quot; + namePattern + &quot;%&quot;);&#10;                    query.setFirstResult(page * size);&#10;                    query.setMaxResults(size);&#10;                    return query.getResultList();&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error buscando usuarios por nombre: &quot; + namePattern, &quot;SEARCH_BY_NAME&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado buscando por nombre: &quot; + namePattern, &quot;SEARCH_BY_NAME&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Long countByActiveLoans() {&#10;        try {&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#10;                try {&#10;                    TypedQuery&lt;Long&gt; query = em.createQuery(&#10;                        &quot;SELECT COUNT(DISTINCT u.id) FROM User u JOIN u.loans l WHERE l.returnedAt IS NULL&quot;, Long.class);&#10;                    return query.getSingleResult();&#10;                } catch (Exception e) {&#10;                    throw new RepositoryException(&quot;Error contando usuarios con préstamos activos&quot;, &quot;COUNT_BY_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#10;                }&#10;            });&#10;        } catch (RepositoryException e) {&#10;            throw e;&#10;        } catch (Exception e) {&#10;            throw new RepositoryException(&quot;Error inesperado contando usuarios con préstamos activos&quot;, &quot;COUNT_BY_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.libraryManagement.repository.impl;&#13;&#10;&#13;&#10;import com.libraryManagement.config.db.TransactionUtil;&#13;&#10;import com.libraryManagement.exception.repository.RepositoryException;&#13;&#10;import com.libraryManagement.model.User;&#13;&#10;import com.libraryManagement.repository.interfaces.UserRepository;&#13;&#10;import jakarta.persistence.NoResultException;&#13;&#10;import jakarta.persistence.TypedQuery;&#13;&#10;&#13;&#10;import java.time.LocalDate;&#13;&#10;import java.util.List;&#13;&#10;import java.util.Optional;&#13;&#10;&#13;&#10;/**&#13;&#10; * IMPLEMENTACIÓN PROFESIONAL DE UserRepository&#13;&#10; * USANDO JPA + TransactionUtil OPTIMIZADO&#13;&#10; *&#13;&#10; * Orden de métodos:&#13;&#10; * 1. Métodos de GenericRepository (CRUD básico)&#13;&#10; * 2. Métodos específicos de UserRepository (en orden de interface)&#13;&#10; */&#13;&#10;public class UserRepositoryImpl implements UserRepository {&#13;&#10;&#13;&#10;    // =====================================================================&#13;&#10;    // MÉTODOS DE GENERIC REPOSITORY - CON JPA + TransactionUtil OPTIMIZADO&#13;&#10;    // =====================================================================&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public User save(User user) {&#13;&#10;        try {&#13;&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    return em.merge(user);&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error al guardar usuario&quot;, &quot;SAVE&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado al guardar usuario&quot;, &quot;SAVE&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public Optional&lt;User&gt; findById(Long id) {&#13;&#10;        try {&#13;&#10;            User user = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    return em.find(User.class, id);&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error consultando usuario por ID: &quot; + id, &quot;FIND&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;            return Optional.ofNullable(user);&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado consultando usuario por ID: &quot; + id, &quot;FIND&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public List&lt;User&gt; findAll() {&#13;&#10;        try {&#13;&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT u FROM User u ORDER BY u.lastName, u.firstName&quot;, User.class);&#13;&#10;                    return query.getResultList();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error consultando todos los usuarios&quot;, &quot;FIND_ALL&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado consultando todos los usuarios&quot;, &quot;FIND_ALL&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public void update(User user) {&#13;&#10;        try {&#13;&#10;            TransactionUtil.executeInTransaction(em -&gt; {&#13;&#10;                try {&#13;&#10;                    em.merge(user);&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error al actualizar usuario&quot;, &quot;UPDATE&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado al actualizar usuario&quot;, &quot;UPDATE&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public void delete(User user) {&#13;&#10;        try {&#13;&#10;            TransactionUtil.executeInTransaction(em -&gt; {&#13;&#10;                try {&#13;&#10;                    User managedUser = em.merge(user);&#13;&#10;                    em.remove(managedUser);&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error al eliminar usuario&quot;, &quot;DELETE&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado al eliminar usuario&quot;, &quot;DELETE&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public boolean existsById(Long id) {&#13;&#10;        try {&#13;&#10;            Long count = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;Long&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT COUNT(u.id) FROM User u WHERE u.id = :id&quot;, Long.class);&#13;&#10;                    query.setParameter(&quot;id&quot;, id);&#13;&#10;                    return query.getSingleResult();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error verificando existencia de usuario por ID: &quot; + id, &quot;EXISTS&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;            return count &gt; 0;&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado verificando existencia por ID: &quot; + id, &quot;EXISTS&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // =====================================================================&#13;&#10;    // BÚSQUEDAS ÚNICAS User&#13;&#10;    // =====================================================================&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public Optional&lt;User&gt; findByEmail(String email) {&#13;&#10;        try {&#13;&#10;            User user = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT u FROM User u WHERE u.email = :email&quot;, User.class);&#13;&#10;                    query.setParameter(&quot;email&quot;, email);&#13;&#10;                    return query.getSingleResult();&#13;&#10;                } catch (NoResultException e) {&#13;&#10;                    return null;&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error consultando usuario por email: &quot; + email, &quot;FIND_BY_EMAIL&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;            return Optional.ofNullable(user);&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado consultando por email: &quot; + email, &quot;FIND_BY_EMAIL&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public Optional&lt;User&gt; findByDni(String dni) {&#13;&#10;        try {&#13;&#10;            User user = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT u FROM User u WHERE u.dni = :dni&quot;, User.class);&#13;&#10;                    query.setParameter(&quot;dni&quot;, dni);&#13;&#10;                    return query.getSingleResult();&#13;&#10;                } catch (NoResultException e) {&#13;&#10;                    return null;&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error consultando usuario por DNI: &quot; + dni, &quot;FIND_BY_DNI&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;            return Optional.ofNullable(user);&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado consultando por DNI: &quot; + dni, &quot;FIND_BY_DNI&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // =====================================================================&#13;&#10;    // VALIDACIONES DE EXISTENCIA CON JPA&#13;&#10;    // =====================================================================&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public boolean existsByEmail(String email) {&#13;&#10;        try {&#13;&#10;            Long count = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;Long&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT COUNT(u.id) FROM User u WHERE u.email = :email&quot;, Long.class);&#13;&#10;                    query.setParameter(&quot;email&quot;, email);&#13;&#10;                    return query.getSingleResult();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error verificando existencia de email: &quot; + email, &quot;EXISTS_BY_EMAIL&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;            return count &gt; 0;&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado verificando email: &quot; + email, &quot;EXISTS_BY_EMAIL&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public boolean existsByDni(String dni) {&#13;&#10;        try {&#13;&#10;            Long count = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;Long&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT COUNT(u.id) FROM User u WHERE u.dni = :dni&quot;, Long.class);&#13;&#10;                    query.setParameter(&quot;dni&quot;, dni);&#13;&#10;                    return query.getSingleResult();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error verificando existencia de DNI: &quot; + dni, &quot;EXISTS_BY_DNI&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;            return count &gt; 0;&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado verificando DNI: &quot; + dni, &quot;EXISTS_BY_DNI&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // =====================================================================&#13;&#10;    // BÚSQUEDAS MÚLTIPLES CON JPA&#13;&#10;    // =====================================================================&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public List&lt;User&gt; findByActiveLoans() {&#13;&#10;        try {&#13;&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT DISTINCT u FROM User u JOIN u.loans l WHERE l.returnedAt IS NULL&quot;, User.class);&#13;&#10;                    return query.getResultList();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error consultando usuarios con préstamos activos&quot;, &quot;FIND_BY_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado consultando usuarios con préstamos activos&quot;, &quot;FIND_BY_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public List&lt;User&gt; findByOverdueLoans() {&#13;&#10;        try {&#13;&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT DISTINCT u FROM User u JOIN u.loans l WHERE l.returnedAt IS NULL AND l.dueDate &lt; :today&quot;, User.class);&#13;&#10;                    query.setParameter(&quot;today&quot;, LocalDate.now());&#13;&#10;                    return query.getResultList();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error consultando usuarios con préstamos vencidos&quot;, &quot;FIND_BY_OVERDUE_LOANS&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado consultando usuarios con préstamos vencidos&quot;, &quot;FIND_BY_OVERDUE_LOANS&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // =====================================================================&#13;&#10;    // PAGINACIÓN CON JPA&#13;&#10;    // =====================================================================&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public List&lt;User&gt; findPaginated(int page, int size) {&#13;&#10;        try {&#13;&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT u FROM User u ORDER BY u.lastName, u.firstName&quot;, User.class);&#13;&#10;                    query.setFirstResult(page * size);&#13;&#10;                    query.setMaxResults(size);&#13;&#10;                    return query.getResultList();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error en consulta paginada&quot;, &quot;FIND_PAGINATED&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado en consulta paginada&quot;, &quot;FIND_PAGINATED&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public List&lt;User&gt; searchByName(String namePattern, int page, int size) {&#13;&#10;        try {&#13;&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;User&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT u FROM User u WHERE LOWER(CONCAT(u.firstName, ' ', u.lastName)) LIKE LOWER(:pattern) ORDER BY u.lastName, u.firstName&quot;, User.class);&#13;&#10;                    query.setParameter(&quot;pattern&quot;, &quot;%&quot; + namePattern + &quot;%&quot;);&#13;&#10;                    query.setFirstResult(page * size);&#13;&#10;                    query.setMaxResults(size);&#13;&#10;                    return query.getResultList();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error buscando usuarios por nombre: &quot; + namePattern, &quot;SEARCH_BY_NAME&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado buscando por nombre: &quot; + namePattern, &quot;SEARCH_BY_NAME&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public Long countByActiveLoans() {&#13;&#10;        try {&#13;&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;Long&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT COUNT(DISTINCT u.id) FROM User u JOIN u.loans l WHERE l.returnedAt IS NULL&quot;, Long.class);&#13;&#10;                    return query.getSingleResult();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error contando usuarios con préstamos activos&quot;, &quot;COUNT_BY_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado contando usuarios con préstamos activos&quot;, &quot;COUNT_BY_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // =====================================================================&#13;&#10;    // VALIDACIONES DE NEGOCIO - Sin cargar colecciones completas&#13;&#10;    // =====================================================================&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public boolean hasActiveLoans(Long userId) {&#13;&#10;        try {&#13;&#10;            Long count = TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;Long&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT COUNT(l.id) FROM Loan l WHERE l.user.id = :userId AND l.returnedAt IS NULL&quot;, &#13;&#10;                        Long.class);&#13;&#10;                    query.setParameter(&quot;userId&quot;, userId);&#13;&#10;                    return query.getSingleResult();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error verificando préstamos activos del usuario: &quot; + userId, &quot;HAS_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;            return count &gt; 0;&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado verificando préstamos activos: &quot; + userId, &quot;HAS_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public Long countActiveLoansByUserId(Long userId) {&#13;&#10;        try {&#13;&#10;            return TransactionUtil.executeInTransactionWithResult(em -&gt; {&#13;&#10;                try {&#13;&#10;                    TypedQuery&lt;Long&gt; query = em.createQuery(&#13;&#10;                        &quot;SELECT COUNT(l.id) FROM Loan l WHERE l.user.id = :userId AND l.returnedAt IS NULL&quot;, &#13;&#10;                        Long.class);&#13;&#10;                    query.setParameter(&quot;userId&quot;, userId);&#13;&#10;                    return query.getSingleResult();&#13;&#10;                } catch (Exception e) {&#13;&#10;                    throw new RepositoryException(&quot;Error contando préstamos activos del usuario: &quot; + userId, &quot;COUNT_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (RepositoryException e) {&#13;&#10;            throw e;&#13;&#10;        } catch (Exception e) {&#13;&#10;            throw new RepositoryException(&quot;Error inesperado contando préstamos activos: &quot; + userId, &quot;COUNT_ACTIVE_LOANS&quot;, &quot;User&quot;, e);&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/repository/interfaces/UserRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/repository/interfaces/UserRepository.java" />
              <option name="originalContent" value="package com.libraryManagement.repository.interfaces;&#10;&#10;import com.libraryManagement.model.User;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public interface UserRepository extends GenericRepository&lt;User, Long&gt; {&#10;&#10;    // =====================================================================&#10;    // BÚSQUEDAS ÚNICAS - Usan Optional porque pueden no existir&#10;    // =====================================================================&#10;&#10;    Optional&lt;User&gt; findByEmail(String email);&#10;    Optional&lt;User&gt; findByDni(String dni);&#10;&#10;    // =====================================================================&#10;    // VALIDACIONES DE EXISTENCIA - Para validaciones rápidas&#10;    // =====================================================================&#10;&#10;    boolean existsByEmail(String email);&#10;    boolean existsByDni(String dni);&#10;&#10;    // =====================================================================&#10;    // BÚSQUEDAS MÚLTIPLES&#10;    // =====================================================================&#10;&#10;    List&lt;User&gt; findByActiveLoans();&#10;    List&lt;User&gt; findByOverdueLoans();&#10;&#10;    // =====================================================================&#10;    // PAGINACIÓN - Para todas las búsquedas masivas&#10;    // =====================================================================&#10;&#10;    List&lt;User&gt; findPaginated(int page, int size);&#10;    List&lt;User&gt; searchByName(String namePattern, int page, int size);&#10;&#10;&#10;    Long countByActiveLoans();&#10;&#10;}" />
              <option name="updatedContent" value="package com.libraryManagement.repository.interfaces;&#10;&#10;import com.libraryManagement.model.User;&#10;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public interface UserRepository extends GenericRepository&lt;User, Long&gt; {&#10;&#10;    // =====================================================================&#10;    // BÚSQUEDAS ÚNICAS - Usan Optional porque pueden no existir&#10;    // =====================================================================&#10;&#10;    Optional&lt;User&gt; findByEmail(String email);&#10;    Optional&lt;User&gt; findByDni(String dni);&#10;&#10;    // =====================================================================&#10;    // VALIDACIONES DE EXISTENCIA - Para validaciones rápidas&#10;    // =====================================================================&#10;&#10;    boolean existsByEmail(String email);&#10;    boolean existsByDni(String dni);&#10;&#10;    // =====================================================================&#10;    // BÚSQUEDAS MÚLTIPLES&#10;    // =====================================================================&#10;&#10;    List&lt;User&gt; findByActiveLoans();&#10;    List&lt;User&gt; findByOverdueLoans();&#10;&#10;    // =====================================================================&#10;    // PAGINACIÓN - Para todas las búsquedas masivas&#10;    // =====================================================================&#10;&#10;    List&lt;User&gt; findPaginated(int page, int size);&#10;    List&lt;User&gt; searchByName(String namePattern, int page, int size);&#10;&#10;&#10;    Long countByActiveLoans();&#10;&#10;    // =====================================================================&#10;    // VALIDACIONES DE NEGOCIO - Sin cargar colecciones completas&#10;    // =====================================================================&#10;&#10;    /**&#10;     * Cuenta préstamos activos de un usuario sin cargar la colección&#10;     * PREVIENE: LazyInitializationException&#10;     * USO: Validaciones antes de eliminar usuario&#10;     */&#10;    boolean hasActiveLoans(Long userId);&#10;&#10;    /**&#10;     * Cuenta total de préstamos activos de un usuario&#10;     * ALTERNATIVA: Si necesitas el número exacto&#10;     */&#10;    Long countActiveLoansByUserId(Long userId);&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/util/UserUtils.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/util/UserUtils.java" />
              <option name="updatedContent" value="package com.libraryManagement.util;&#10;&#10;import java.time.LocalDate;&#10;import java.time.Period;&#10;&#10;/**&#10; * UTILIDADES PARA USER - Solo cálculos puros sin lógica de negocio&#10; *&#10; * Contiene métodos estáticos para cálculos que no dependen del estado&#10; * de la aplicación ni requieren acceso a base de datos&#10; */&#10;public class UserUtils {&#10;&#10;    /**&#10;     * Calcula la edad basada en fecha de nacimiento&#10;     *&#10;     * @param dateOfBirth fecha de nacimiento&#10;     * @return edad en años, null si dateOfBirth es null, 0 si es fecha futura&#10;     */&#10;    public static Integer calculateAge(LocalDate dateOfBirth) {&#10;        if (dateOfBirth == null) {&#10;            return null;&#10;        }&#10;&#10;        LocalDate now = LocalDate.now();&#10;        if (dateOfBirth.isAfter(now)) {&#10;            return 0; // Fecha futura = 0 años&#10;        }&#10;&#10;        return Period.between(dateOfBirth, now).getYears();&#10;    }&#10;&#10;    /**&#10;     * Extrae el nombre de ciudad de una dirección&#10;     *&#10;     * @param address dirección del usuario&#10;     * @return nombre de la ciudad o null si address es null&#10;     */&#10;    public static String extractCityName(com.libraryManagement.model.Address address) {&#10;        if (address == null) {&#10;            return null;&#10;        }&#10;        return address.getCity();&#10;    }&#10;&#10;    /**&#10;     * Calcula estado de membresía basado en el estado del usuario&#10;     *&#10;     * REGLAS DE NEGOCIO:&#10;     * - SUSPENDED: Tiene préstamos vencidos&#10;     * - LIMITED: 3+ préstamos activos&#10;     * - ACTIVE: Estado normal&#10;     *&#10;     * @param user usuario a evaluar&#10;     * @return estado de membresía&#10;     */&#10;    public static String calculateMembershipStatus(com.libraryManagement.model.User user) {&#10;        if (user == null || user.getLoans() == null) {&#10;            return &quot;ACTIVE&quot;;&#10;        }&#10;&#10;        // Contar préstamos activos&#10;        long activeLoans = user.getLoans().stream()&#10;            .filter(loan -&gt; loan.getReturnedAt() == null)&#10;            .count();&#10;&#10;        // Verificar préstamos vencidos&#10;        boolean hasOverdueLoans = user.getLoans().stream()&#10;            .filter(loan -&gt; loan.getReturnedAt() == null)&#10;            .anyMatch(loan -&gt; loan.getDueDate().isBefore(LocalDate.now()));&#10;&#10;        if (hasOverdueLoans) {&#10;            return &quot;SUSPENDED&quot;;&#10;        } else if (activeLoans &gt;= 3) {&#10;            return &quot;LIMITED&quot;;&#10;        } else {&#10;            return &quot;ACTIVE&quot;;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Formatea nombre completo del usuario&#10;     *&#10;     * @param firstName nombre&#10;     * @param lastName apellido&#10;     * @return nombre completo formateado&#10;     */&#10;    public static String formatFullName(String firstName, String lastName) {&#10;        if (firstName == null &amp;&amp; lastName == null) {&#10;            return &quot;Nombre no disponible&quot;;&#10;        }&#10;        &#10;        String first = firstName != null ? firstName.trim() : &quot;&quot;;&#10;        String last = lastName != null ? lastName.trim() : &quot;&quot;;&#10;        &#10;        if (first.isEmpty() &amp;&amp; last.isEmpty()) {&#10;            return &quot;Nombre no disponible&quot;;&#10;        }&#10;        &#10;        return (first + &quot; &quot; + last).trim();&#10;    }&#10;&#10;    /**&#10;     * Valida formato de DNI argentino&#10;     *&#10;     * @param dni documento a validar&#10;     * @return true si es válido&#10;     */&#10;    public static boolean isValidArgentinianDNI(String dni) {&#10;        if (dni == null || dni.trim().isEmpty()) {&#10;            return false;&#10;        }&#10;        &#10;        // Remover espacios y puntos&#10;        String cleanDNI = dni.replaceAll(&quot;[\\s.]&quot;, &quot;&quot;);&#10;        &#10;        // Debe tener entre 7 y 8 dígitos&#10;        return cleanDNI.matches(&quot;\\d{7,8}&quot;);&#10;    }&#10;&#10;    /**&#10;     * Valida formato de email&#10;     *&#10;     * @param email email a validar&#10;     * @return true si es válido&#10;     */&#10;    public static boolean isValidEmail(String email) {&#10;        if (email == null || email.trim().isEmpty()) {&#10;            return false;&#10;        }&#10;        &#10;        // Regex básico para email&#10;        String emailRegex = &quot;^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$&quot;;&#10;        return email.matches(emailRegex);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/libraryManagement/util/validation/DTOValidator.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/libraryManagement/util/validation/DTOValidator.java" />
              <option name="originalContent" value="package com.libraryManagement.util.validation;&#10;&#10;import jakarta.validation.ConstraintViolation;&#10;import jakarta.validation.Validation;&#10;import jakarta.validation.Validator;&#10;import jakarta.validation.ValidatorFactory;&#10;import com.libraryManagement.util.Logger;&#10;&#10;import java.util.Set;&#10;import java.util.stream.Collectors;&#10;&#10;/**&#10; * VALIDADOR MANUAL PARA DTOs&#10; *&#10; * Ejecuta las validaciones de @NotNull, @NotBlank, @Email, etc.&#10; * que están en los DTOs pero no se ejecutan automáticamente con Jackson.&#10; */&#10;public class DTOValidator {&#10;&#10;    private static final Validator validator;&#10;&#10;    static {&#10;        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();&#10;        validator = factory.getValidator();&#10;        Logger.info(&quot;DTOValidator&quot;, &quot;Inicializado correctamente&quot;);&#10;    }&#10;    /**&#10;     * Valida un DTO y lanza excepción si hay errores&#10;     */&#10;    public static &lt;T&gt; void validate(T dto) {&#10;        if (dto == null) {&#10;            Logger.warn(&quot;DTOValidator&quot;, &quot;Intento de validar DTO nulo&quot;);&#10;            throw new IllegalArgumentException(&quot;DTO no puede ser nulo&quot;);&#10;        }&#10;&#10;        Set&lt;ConstraintViolation&lt;T&gt;&gt; violations = validator.validate(dto);&#10;&#10;        if (!violations.isEmpty()) {&#10;            String errorMessage = violations.stream()&#10;                    .map(ConstraintViolation::getMessage)&#10;                    .collect(Collectors.joining(&quot;, &quot;));&#10;&#10;            Logger.warn(&quot;Validación fallida para &quot; + dto.getClass().getSimpleName() +&#10;                &quot;: &quot; + violations.size() + &quot; errores encontrados - &quot; + errorMessage);&#10;&#10;            violations.forEach(violation -&gt;&#10;                Logger.debug(&quot;   Campo '&quot; + violation.getPropertyPath() + &quot;': &quot; +&#10;                    violation.getMessage() + &quot; (valor: '&quot; + violation.getInvalidValue() + &quot;')&quot;)&#10;            );&#10;&#10;            throw new IllegalArgumentException(&quot;Datos inválidos: &quot; + errorMessage);&#10;        }&#10;&#10;        Logger.debug(&quot;Validación exitosa para &quot; + dto.getClass().getSimpleName());&#10;    }&#10;    /**&#10;     * Valida un DTO y retorna lista de errores sin lanzar excepción&#10;     */&#10;    public static &lt;T&gt; Set&lt;String&gt; getValidationErrors(T dto) {&#10;        if (dto == null) {&#10;            Logger.warn(&quot;DTOValidator&quot;, &quot;Intento de obtener errores de DTO nulo&quot;);&#10;            return Set.of(&quot;DTO no puede ser nulo&quot;);&#10;        }&#10;&#10;        Set&lt;ConstraintViolation&lt;T&gt;&gt; violations = validator.validate(dto);&#10;&#10;        if (!violations.isEmpty()) {&#10;            Logger.debug(&quot;Obteniendo &quot; + violations.size() + &quot; errores de validación para &quot; +&#10;                dto.getClass().getSimpleName());&#10;        }&#10;&#10;        return violations.stream()&#10;                .map(ConstraintViolation::getMessage)&#10;                .collect(Collectors.toSet());&#10;    }&#10;&#10;    /**&#10;     * Verifica si un DTO es válido&#10;     */&#10;    public static &lt;T&gt; boolean isValid(T dto) {&#10;        if (dto == null) {&#10;            Logger.debug(&quot;DTO nulo considerado inválido&quot;);&#10;            return false;&#10;        }&#10;&#10;        boolean valid = validator.validate(dto).isEmpty();&#10;&#10;        Logger.debug(&quot;Validación rápida para &quot; + dto.getClass().getSimpleName() + &quot;: &quot; +&#10;            (valid ? &quot;VÁLIDO&quot; : &quot;INVÁLIDO&quot;));&#10;&#10;        return valid;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.libraryManagement.util.validation;&#13;&#10;&#13;&#10;import jakarta.validation.ConstraintViolation;&#13;&#10;import jakarta.validation.Validation;&#13;&#10;import jakarta.validation.Validator;&#13;&#10;import jakarta.validation.ValidatorFactory;&#13;&#10;import java.util.Set;&#13;&#10;import java.util.stream.Collectors;&#13;&#10;&#13;&#10;/**&#13;&#10; * VALIDADOR GENÉRICO PARA DTOs&#13;&#10; * &#13;&#10; * Contiene validaciones TRANSVERSALES que se usan en toda la aplicación&#13;&#10; * NO contiene lógica de negocio específica de entidades&#13;&#10; */&#13;&#10;public class DTOValidator {&#13;&#10;&#13;&#10;    private static final ValidatorFactory factory = Validation.buildDefaultValidatorFactory();&#13;&#10;    private static final Validator validator = factory.getValidator();&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Valida un DTO usando anotaciones Bean Validation&#13;&#10;     */&#13;&#10;    public static &lt;T&gt; void validate(T dto) {&#13;&#10;        Set&lt;ConstraintViolation&lt;T&gt;&gt; violations = validator.validate(dto);&#13;&#10;&#13;&#10;        if (!violations.isEmpty()) {&#13;&#10;            String errorMessage = violations.stream()&#13;&#10;                    .map(ConstraintViolation::getMessage)&#13;&#10;                    .collect(Collectors.joining(&quot;, &quot;));&#13;&#10;            &#13;&#10;            throw new IllegalArgumentException(&quot;Datos inválidos: &quot; + errorMessage);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Valida un DTO y retorna lista de errores sin lanzar excepción&#13;&#10;     */&#13;&#10;    public static &lt;T&gt; Set&lt;String&gt; getValidationErrors(T dto) {&#13;&#10;        Set&lt;ConstraintViolation&lt;T&gt;&gt; violations = validator.validate(dto);&#13;&#10;&#13;&#10;        return violations.stream()&#13;&#10;                .map(ConstraintViolation::getMessage)&#13;&#10;                .collect(Collectors.toSet());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Verifica si un DTO es válido&#13;&#10;     */&#13;&#10;    public static &lt;T&gt; boolean isValid(T dto) {&#13;&#10;        return validator.validate(dto).isEmpty();&#13;&#10;    }&#13;&#10;&#13;&#10;    // =====================================================================&#13;&#10;    // VALIDACIONES TRANSVERSALES - Usadas en toda la aplicación&#13;&#10;    // =====================================================================&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Valida formato de DNI argentino (TRANSVERSAL)&#13;&#10;     */&#13;&#10;    public static boolean isValidArgentinianDNI(String dni) {&#13;&#10;        if (dni == null || dni.trim().isEmpty()) {&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;        &#13;&#10;        String cleanDNI = dni.replaceAll(&quot;[\\s.]&quot;, &quot;&quot;);&#13;&#10;        return cleanDNI.matches(&quot;\\d{7,8}&quot;);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Valida formato de email (TRANSVERSAL)&#13;&#10;     */&#13;&#10;    public static boolean isValidEmail(String email) {&#13;&#10;        if (email == null || email.trim().isEmpty()) {&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;        &#13;&#10;        String emailRegex = &quot;^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$&quot;;&#13;&#10;        return email.matches(emailRegex);&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Valida que un string no esté vacío (TRANSVERSAL)&#13;&#10;     */&#13;&#10;    public static boolean isNotBlank(String text) {&#13;&#10;        return text != null &amp;&amp; !text.trim().isEmpty();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Valida rango numérico (TRANSVERSAL)&#13;&#10;     */&#13;&#10;    public static boolean isInRange(Number value, Number min, Number max) {&#13;&#10;        if (value == null || min == null || max == null) {&#13;&#10;            return false;&#13;&#10;        }&#13;&#10;        &#13;&#10;        double val = value.doubleValue();&#13;&#10;        double minVal = min.doubleValue();&#13;&#10;        double maxVal = max.doubleValue();&#13;&#10;        &#13;&#10;        return val &gt;= minVal &amp;&amp; val &lt;= maxVal;&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>